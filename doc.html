<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Angular!!</title>
  </head>
  <body>
    <section>
      <h1>Angular</h1>
      <p>Framerwork front-end desenvolvido entre Google e Microsoft</p>
    </section>
    <section>
      <h1>Introdução</h1>
      <p>Aulas 1 a 8</p>
      <section>
        <h1>Web Components</h1>
        <p>
          O angular funciona com angular components, que nada menos nada mais
          são components HTML, desenvolvidos em partes separadas e organizadas
          em conjuntos para exibição na página
        </p>
        <p>Um só componente pode conter outros components etc</p>
        <p>
          Por convenção, para criação de components, devemos cirar a pasta do
          component,e o arquivo .component.ts, que é o TS do nosso component. E
          o component, deve unica e exclusivamente conter código de iteração com
          o template, código de iteração com bancos de dados e apis devem ser
          criados em serviçes
        </p>
        <p><b> meu-primeiro.component.ts</b></p>
        <p>
          Dentre deste arquivo . component, vamos importar o Component do
          angular ' <b> import { Component } from '@angular/core '</b>
        </p>
        <p>
          Logo em seguida usamos o decorator do component e passamos como
          parametros o seletor, o template em caso de template inline, o
          templateUrl em caso de arquivo HTML, e o styleUrl em caso de arquivo
          css. ficando
        </p>
        <p>
          <b> @Component</b>({ selector: 'meu-primeiro-component', template: `
          código html`, styleUrl: ['./pasta/do/arquivo.css]'})
        </p>
        <p>
          E logo em seguida, como se trata de um decorator devemos informar a
          classe
        </p>
        <p>export class MeuPrimeiroComponent{ código da classe}</p>
        <p>
          Após isto, para utilizarmos na página principal da nossa aplicação,
          devemos importar o nosso component, no arquivo '
          <b> app.module.ts</b> ', após importa-lo, devemos declara-lo no
          decorator <b> @NgModule </b>no array da chave ' declarations:
          [AppComponent, MeuPrimeiroComponent],
        </p>
        <p>
          Então sim, podemos adicionar a tag informada em selector do nosso
          component no arquivo html principal da nossa aplicação o '
          app.component.html '
        </p>
        <p>
          Tambem podemos e devemos utilizar o CLI para criação do component de
          forma dinamica, basta digitar no terminal '<b>
            ng g c nome-do-component</b
          >', que o próprio angular se encarrega de gerar os arquivos e o import
          no @NgModule do nosso app.module.ts
        </p>
        <p>
          <a href="https://angular.io/api/core/Component"
            >Documentação do components</a
          >
        </p>
        <p><strong> Introdução: Hello, world! - Aula 3</strong></p>
      </section>
      <hr />
      <section>
        <h1>Modules</h1>
        <p>
          Outra poderosíssima ferramenta do angular, e o seu modo de produção
        </p>
        <p>
          Com modulos, podemos separar partes do código, como um modulo só para
          login, outro apenas para produtos, etc.
        </p>
        <p>
          Evitando assim congestionar o modulo principal da nossa aplicação o
          <b>AppModule</b>, dentro do modulo principal, temos o
          <b>bootstrap:</b> importado apenas nele, que significa qual a modulo
          principal irá puxar toda a aplicação, tambem o <b>BrowserModule</b>,
          do qual prepara a aplicação para ser rodada em um browser, há tambem o
          <b>FormsModule</b>, utilizado em formulários, e o
          <b>HttpModule</b> que permite utilizarmos as diretivas https, para
          requisição ajax. Todos estes itens estão dentro do decorator
          <b>@NgModule</b>, há tambem a chave do <b>providers</b>, que é
          responsável pelos serviços que desejamos importat.
        </p>
        <p>
          Podemos criar um module com o comando
          <b> ng c m nome-do-module </b> via cli, irá criar a pasta com o nome
          do module e o .module.ts, este module tambem está acompanhado do
          decorator <b>@NgModule</b>, ao ser criado pelo cli tambem ja irá ser
          importado nos imports do modulo principal, dentro dos nossos features
          modules, que são os módulos de funcionalidades, podemos ter vários
          components sendo importado nesses módulos e tambem exportados na chave
          do exports, ao ser exportado o component dentro do feature module
          poderá ser utilizado no template que está sendo importado o nosso
          module.
        </p>

        <p>
          Após criar o nosso module, o component do module e tambem exportar o
          component do module, podemos criar outros components filhos, que podem
          ser utilizados no component do module, porem nao em outros components,
          criando assim components de forma privada.
        </p>
        <h2>Module principal</h2>
        <p>@NgModule ({</p>
        <p>declarations: [declaração dos components aqui]</p>
        <p>imports: [declaração de outros modules aqui]</p>
        <p>providers: [declaração dos services aqui]</p>
        <p>bootstrap: [component principal da aplicação]</p>
        <h2>Feature module</h2>
        <p>@NgModule ({</p>
        <p>imports: [declaração de outros modules aqui]</p>
        <p>declarations: [declaração dos components aqui]</p>
        <p>exports: [export do component principal]</p>
        <p><strong> Introdução: Módulos (ngModule) - Aula 5</strong></p>
      </section>
      <hr />
      <section>
        <h1>Template</h1>
        <p>
          O template é o código HTML do nosso component, pode ser escrito inline
          na chave <b>template:`código html`</b> mas por convenção deve ser
          utilizado assim apenas em casos em que o template tenha no máximo até
          3 linhas
        </p>
        <p>
          Caso ultrapasse isso deve ser utilizado a chave
          <b>templateUrl:[./caminho/do/html.html]</b>
        </p>
        <p>
          No nosso template, podemos referenciar variáveis com
          <b>interpolação {{variável}}</b>, a variável deve ser declarada dentro
          da nossa classe do component com type anotation
        </p>
        <p>Tambem podemos usar diretivas como ngFor, ngIf como em ejs</p>
        <p>
          Podemos tambem definir variável de escopo do template, adicionando um
          # na frente e logo em seguida um nome #variável, sedo possível
          acessa-la de qualquer lugar no template
        </p>

        <p><b> Introdução: Template - Aula 6</b></p>
      </section>
      <hr />
      <section>
        <h1>Serviços (Services) e Injeção de dependência (DI)</h1>
        <p>
          Os serviços, contem todo o código que procura e recebe informações
          externas a aplicação, como em bancos de dados e apis
        </p>
        <p>
          É um classe simples com o decorator <b>@Injectable()</b>, que permite
          que o serviços seja utilizado em injeção de dependência.
        </p>
        <p>
          Dentro da classe teremos métodos normais como em uma classe com a
          lógica do código, e para utilizar como DI, devemos declarar no
          constructor da classe e que desejamos receber o service, geralmente
          como private.
        </p>
        <p><b> Introdução: Services e Injeção de dependência - Aula 7</b></p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Data binding</h1>
      <p>Aulas da 9 a 11</p>
      <p>
        Em Data binding que é o como variáveis e métodos que retornam algum
        valor, podem se comunicar com o template (html) mostrando na tela o
        valor.
      </p>
      <p>Temos 4 tipos de binding em angular, são eles:</p>
      <p>
        <b>Interpolation</b>: {{valor}}; usado quando desejamos mostrar o valor
        de algum atributo do component.. a informação vai do component para o
        template.
      </p>
      <p>
        <b>One-way data binding: [propriedade]="valor": </b> Quando temos alguma
        tag no HTML que tem propriedades, podemos definir o valor da própriedade
        com algum atributo da classe como em uma tag img temos a propriedade src
        e fazemos o property binding como [width] = "valor"..a informação vai do
        component para o template
      </p>
      <p>
        <b>Event binding: (evento)="handler";</b> quando interagimos com a
        lógica do component através do template.
      </p>
      <p>
        <b>Two-way data binding: [(ngModel)]="propriedade";</b> quando
        conseguimos tanto interagir com o template quanto com a lógica do
        component
      </p>
      <hr />
      <section>
        <h1>Property binding e Interpolação</h1>
        <p>
          Interpolation permite adicionar valores do código TS para o template
        </p>
        <p>
          Já o property binding permite adicionar valores as tags HTML que
          possuem propriedades
        </p>
        <p><b> Data Binding: Property binding e Interpolação - Aula 9</b></p>
      </section>
      <hr />
      <section>
        <h1>Class e Style binding</h1>
        <p>
          Podemos usar tambem o property binding para definir classes com
          valores, e o style binding para definir estilos tambem com o property
          binding.
        </p>
        <p><b>[class.nome-da-classe]="valor"</b></p>
        <p><b>[style.propriedade]="valor"</b></p>
        <p><b> Data Binding: Class e Style binding - Aula 10</b></p>
      </section>
      <hr />
      <section>
        <h1>Event binding</h1>
        <p>Para utilizarmos event binding é simples:</p>
        <p>
          <b>(evento)="lógica()"</b> basta adicionar o evento entre parênteses
          como click, mouseover,etc... e o método a ser chamado do component
          passando ou não parâmetros
        </p>
        <p>Importane: podemos capurar o evento com $event</p>
        <p><b> Data Binding: Event Binding - Aula 11</b></p>
      </section>
      <hr />
      <section>
        <h1>Two-way data binding</h1>
        <p>
          Com o two-way data binding, conseguimos tanto altera o valor no
          template como tambem no component, sendo muito útil, sua sintaxe é
          simples:
        </p>
        <p>
          <b> [(ngModel)]="atributo"</b> Alterando em tempo real o o template e
          o componet
        </p>
        <p>
          Devemos nos atentar caso estejamos utilizando o ngModel em um feature
          module, pois devemos importar o FormsModule, ja que o ngModel é uma
          diretiva do FormsModule
        </p>
        <p><b> Data Binding: Two-way data binding - Aula 12</b></p>
      </section>
      <hr />
      <section>
        <h1>Input Property</h1>
        <p>
          Quando usamos components dentro de outros componentes, e necessitamos
          passar informações para esse outro component, podemos utilizar o input
          property:
        </p>
        <p>
          <b> < component [propriedade]="atributo" > < component ></b>, isso
          dentro da tag do component alvo, e no nosso component.ts devemos
          declarar o atributo com o decorator @Input(), que pode receber como
          parâmetro uma string para expor o atributo com o nome desejado.
        </p>
        <p>
          Quando informamos um valor e não um atributo, nao precisamos utilizar
          as chaves: <b>propriedade="valor"</b>
        </p>
        <p>
          A nivel de curiosidade, podemos declarar os inputs em um array dentro
          do @Component, com a chave inputs: [], e dentro do array informar o
          nome dos atributos a receberem inputs, porem por convenção devemos
          utilizar o decorator.
        </p>
        <p>
          Não podemos esquecer de realizar o import do Input de dentro do
          angular/core
        </p>
        <p><b> Data Binding: Input Property - Aula 13</b></p>
      </section>
      <hr />
      <section>
        <h1>Output Property</h1>
        <p>
          Assim como podemos passar valores para um component filho, podemos
          transmitir informações do component filho para o component pai
        </p>
        <p>
          Devemos criar um evento no component filho com
          <b>meuEvento = new EventEmitter</b>(não esquecer de importa-lo) um
          novo evento, e tambem utilizar o decorator <b> @Output()</b> (tambem
          não esquecer de importa-lo), para exportar o evento.
        </p>
        <p>
          Após isso, podemos utilizar o evento criado:
          <b>meu-evento.emit(valor), em qualquer método</b>
        </p>
        <p>
          No elemento pai, devemos observar o evento, e capturar o valor com um
          método no elemento pai
        </p>
        <p>
          < elemento-filho <b> (meuEvento)="onMeuEvento(valor)" > </b> <
          elemento-filho >
        </p>
        <p>
          E com a captura do valor com um método no elemento pai, podemos
          manipular o valor
        </p>
        <p><b> Data Binding: Output Property - Aula 14</b></p>
      </section>
      <hr />
      <section>
        <h1>Ciclo de vida do component</h1>
        <p>
          São os estágios que os componentes passam, sendo eles por ordem de
          execução:
        </p>
        <p><b>constructor</b> construtor do component</p>
        <p>
          <b>ngOnChanges</b>Executado quando há mudanças no component, altamente
          recomendado para elementos que utilizam input property
        </p>
        <p>
          <b>ngOnInit</b>Quando o component é inicializado, altamente
          recomendado para components que não tem property binding e para
          elementos que necessitam de conexão com algum meio externo
        </p>
        <p><b>ngDoCheck</b>A cada ciclo de verificação de mudanças</p>
        <p>
          <b>ngAfterContentInit</b>Depois que o conteúdo externo é inserido na
          view
        </p>
        <p>
          <b>ngAfterContentChecked</b>A cada verificação do conteúdo inserido
        </p>
        <p><b>ngAfterViewtInit</b>Depois que todo a view é carregada</p>
        <p>
          <b>ngAfterViewtChecked</b>A cada verificação de mudança no view do
          component
        </p>
        <p>
          <b>ngOnDestroy</b>Quando a diretiva, pipe, service, component é
          destruído. Util para finalizar um observable.
        </p>
        <p>
          Todos devem ser implementados na classe e importados do @angular/core
        </p>
        <p><b> Data Binding: Ciclo de vida do component - Aula 15</b></p>
      </section>
      <hr />
      <section>
        <h1>Acesso ao DOM e o Template com ViewChild</h1>
        <p>
          Quando declaramos uma váriavel local no template com o #, podemos
          acessa-la dentro do component, atribuindo a uma variável com o
          decorator <b> @ViewChild()</b> que tambem deve ser importado, e
          passando o nome da variável do template como parâmetro pra o ViewChild
        </p>
        <p>
          <b>@ViewChild('variavelTemplate') variávelComponent: ElementRef</b>
          Devemos declarar a variável do component que recebe o viewchild como
          <b>ElementRef</b> ( que tambem deve ser importado), nele contem o
          atributo nativeElement, que retorna o elemento nativo do template, e
          através dele podemos recuperar valores e etc
        </p>
        <p>
          <b>
            Data Binding: Acesso ao DOM e o Template com ViewChild - Aula 16</b
          >
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Angular CLI</h1>
      <section>
        <h1>Instalação e criação de projetos</h1>
        <p>
          Para instalar o Angular CLI, devemos ter o nodejs e o npm instalado,
          funciona acima da versão 4.0
        </p>
        <h3>Comandos Angular CLI:</h3>
        <section>
          <p><b>ng init</b> inicia um projeto angular no diretório</p>
          <p>
            <b>ng new my-app</b> inicia um projeto criando a pasta e instalando
            todas as dependências
          </p>
          <p></p>

          <p>
            <b>ng serve</b> serve o nosso projeto ao browser para que possamos
            ve-lo pelo navegador
          </p>
          <b> Angular CLI: Instalando e criando projetos - Aula 17</b>
        </section>
        <section>
          <h3>Gerando as classes do angular</h3>
        </section>
        <p>
          <b>ng g</b> este comando, o generate é o que gera nossas classes com
          os nomes e arquivos e ja toda a estrutura de acordo com a classe
          gerada com o melhor padrão para o angular
        </p>

        <ul>
          <li>
            <b>ng g component meu-component</b>; gera um component com toda a
            sua estrutura
          </li>
          <li>
            <b>ng g service meu-servico</b>; gera um servico com toda a sua
            estrutura
          </li>
          <li>
            <b>ng g directive minha-diretiva</b>; gera uma diretiva com toda a
            sua estrutura
          </li>
          <li>
            <b>ng g pipe meu-pipe</b>; gera um pipe com toda a sua estrutura
          </li>
          <li>
            <b>ng g class minha-classe</b>; gera uma classe com toda a sua
            estrutura
          </li>
          <li>
            <b>ng g interface miha-interface</b>; gera uma interface com toda a
            sua estrutura
          </li>
          <li>
            <b>ng g enum meu-enum</b>; gera um enum com toda a sua estrutura
          </li>
        </ul>
        <b> Angular CLI: ng generate - Aula 18</b>
      </section>
      <section>
        <h1>Usando pre-processadores</h1>
        <p>
          Para utilizar pre processadores como sass, less, stylus, ao iniciar o
          projeto o próprio CLI, questiona qual extensão desejamos utilizar
        </p>
        <p>
          Caso ja tenhamos um projeto iniciado, podemos alterar com o comando
          <b>ng set defaults.styleExt scss</b>, com a extensão desejada, assim
          todo novo component criado utilizara a nova extensão, mas nao altera a
          extensão de components já gerados
        </p>
        <b> Angular CLI: Pre processadores com angular - Aula 19</b>
      </section>
      <section>
        <h1>lint, test, e2e</h1>
        <ul>
          <li>
            <b>ng lint</b> serve para fazer o lint do nosso app parar verificar
            se está de acordo com o style guide do angular, muito util!
          </li>
          <li>
            <b>ng test</b> executa todos os arquivos .spec.ts do nosso app, e
            roda todos os testes, os teste são realizado por <b> jasmine</b> e
            interpretado pelo <b> karma</b>
          </li>
          <li>
            <b>ng e2e</b> realiza teste end to end da aplicação com o
            protractor, (teste de integração)
          </li>
        </ul>
        <b> Angular CLI: ng lint, teste, e2e - Aula 20 </b>
      </section>
      <section>
        <h1>Gerando build de produção</h1>
        <p>Para gerar build de desenvolvimento e produção temos:</p>
        <ul>
          <li>
            <b>ng build --dev</b>; gera a pasta dist com os arquivos utilizados
            em produção, porem ainda legíveis e indentados, útil para debug
          </li>
          <li>
            <b
              >ng build --prod; gera a pasta dist com os arquivos de produção,
              completamente minificados e ilegíveis, apenas o código funcional
              para a aplicação</b
            >
          </li>
        </ul>
        <b> Angular CLI: Gerando build de produção - Aula 22 </b>
      </section>
      <hr />
      <section>
        <h1>Instalando bibliotecas externas</h1>
        <p>
          Junto com o angular, podemos instalar bibliotecas externas de diversas
          formas
        </p>
        <p>
          Informando o caminho dos styles e scripts direto no arquivo
          <b>angular.json</b>
        </p>
        <p>
          Direto no arquivo index.html ou style.css ( não recomendável, apenas
          para fontes do google)
        </p>
        <p>
          E tambem instalando através do npm e importando direto no modulo
          principal, ou nos módulos que vamos utilizar.
        </p>
        <b> Angular CLI: Instalando bibliotecas externas - Aula 23 </b>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Diretivas</h1>
      <p>
        <b>Diretivas estruturais</b>Interagem com a view e modificam o DOM ou o
        HTML(*ngFor, *ngIf)
      </p>
      <p>
        <b>Diretivas de atributos</b>Interagem com com o elemento em que foram
        aplicadas (ng-class, ng-style)
      </p>
      <p>
        Muito importante, devemos importar o CommonModule para o modulo dos
        components em que vamos utilizar as diretivas nativas
      </p>
      <hr />
      <section>
        <h1>*ngIf</h1>
        <p>
          O *ngIf funciona de forma similar ao if else do JS normal, apenas muda
          a sintaxe, atribuímos ao como propriedade da tag HTML a palavra
          reservada <b> *ngIf="código"</b>
        </p>
        <p>
          Devemos ficar atentos, pois o ngIf alterado o DOM e pode ser custoso,
          então sempre que possível (em árvores pequenas do DOM), podemos e
          devemos utilizar o [hidden], pois é menos custoso a performance
        </p>
        <b> Diretivas: ngIf - Aula 25 </b>
      </section>
      <hr />
      <section>
        <h1>*ngSwitch, ngSwitchCase, ngSwitchDefault</h1>
        <p>Tambem funcionando de forma similar ao switch case do JS</p>
        <p>definimos em uma tag pai o <b> [ngSwitch]="variável"</b></p>
        <p>
          nos elementos filhos, usamos o <b>*ngSwitchCase="valor1"</b>, e o
          código dentro da tag
        </p>
        <p>
          e para valores padrão definimos o <b>*ngSwitchDefault</b> e o valor a
          ser exibido tambem dentro da tag
        </p>
        <b> Diretivas: ngIf - Aula 26 </b>
      </section>
      <section>
        <h1>*ngFor</h1>
        <p>
          Outra diretiva nativa muito ultio no caso de iteração com arrays,
          basta adicionar o <b>*ngFor="let item of array"</b> e dentro da tag
          HTML interpolar com a váriavel local criada {{item}}.
        </p>
        <p>
          Podemos tambem utilizar o index adicionando <b>, let i = index </b>,
          logo após o array no *ngFor
        </p>
        <b> Diretivas: ngFor - Aula 27 </b>
      </section>
      <hr />
      <section>
        <h1>Sobre o * e template</h1>
        <p>
          Quando utilizamos o * antes da diretiva, quer dizer, que por baixo dos
          panos, o angular está criando uma tag template e como property binding
          informando a nossa diretiva
        </p>
        <b> Diretivas: Sobre o * e template - Aula 28 </b>
      </section>
      <hr />
      <section>
        <h1>[ngClass]</h1>
        <p>
          O <b>[ngClass]</b> substitui em casos de verificação para muitas
          classes, o class binding, sendo possível com o ngClass retornar um
          objeto, com a chave entra aspas e o seu valor como a condição
        </p>
        <p>[ngClass]="'class: condição'"</p>
        <b> Diretivas: ngClass - Aula 29 </b>
      </section>
      <section>
        <h1>[ngStyle]</h1>
        <p>
          Funcionar de forma idêntica ao [ngClass], porem com atributos de
          estilo, e com condicionais ternarias
        </p>
        <p><b>[ngStyle]</b>="{'backgroundColor: (ativo ? 'blue : gray}</p>
        <b> Diretivas: ngStyle - Aula 30 </b>
      </section>
      <hr />
      <section>
        <h1>Elvis operator</h1>
        <p>
          O elvis operator, previne a quebra do código caso o nosso objeto tenha
          uma chave com o valor nulo, havendo o valor nulo ele não é
          interpretado
        </p>
        <p>
          <b>obj.exemplo?.mostrar</b> neste caso temos o objeto, e dentro do
          objeto a chave exemplo, se essa chave não for nula e tiver a chave
          mostrar, ele mostrará, mas se a chave do exemplo for nula e le não é
          exibido
        </p>
        <p><b>Diretivas: Operador Elvis - Aula 31</b></p>
      </section>
      <hr />
      <section>
        <h1>ng-content</h1>
        <p>
          Com o input property conseguimos passar dados através de variáveis
          para o component, com o ng-content conseguimos passar conteúdo HTML,
          através da tag <b> < ng-content > </b> no component que vai receber o
          conteúdo, e no component que irá receber o conteúdo passar a div com a
          class de acordo com o <b> select </b>do ng-content
        </p>
        <p>Component que envia <b>< div class="titulo">Titulo enviado</b></p>
        <p>
          Component que recebe
          <b>< ng-content select=".titulo"></b>
        </p>
        <p>E será exibido o conteúdo de acordo com o enviado</p>
        <p><b>Diretivas: ng-content - Aula 32</b></p>
      </section>
      <hr />
      <section>
        <h1>Criando diretivas de atributos customizadas</h1>
        <p>
          Para criar diretivas de atributos (que alteram o estilo do elemento)
          podemos gerar uma diretiva pelo cli <b>ng g d nome-diretiva</b>
        </p>
        <p>
          Após a criação teremos o decorator <b> @Directive</b>, e como
          parâmetro o <b>selector</b> que vai ser o nome da diretiva dentro da
          tag, , para referenciarmos o elemento em que a diretiva foi inserida,
          devemos importar o <b>ElementRef</b>, e para manipular o elemento
          devemos importar e utilizar o <b>Renderer2</b>
        </p>
        <p>
          Tanto o ElementRef quanto Renderer2 devem ser importados como injeção
          de dependência no constructor com
          <b>private _elementRef: ElementRef</b> e
          <b>private _renderer: Renderer2</b>
        </p>
        <p>
          O após criar o atributo recebendo o ElementRef, temos que acessar o
          elemento dentro do atributo nativeElement, passando para o _renderer
        </p>
        <p>
          No renderer, temos diversos métodos, passamos no
          <b
            >.setElementStyle(this._elementRef.nativeElement, propriedadeCSss,
            valor-da-propriedade)</b
          >
        </p>
        <p>
          E está criado a nossa diretiva, bata utiliza-la dentro da tag do
          elemento a ser modificado
        </p>
        <p><b>Diretivas: Criando uma diretiva de atributo - Aula 33</b></p>
      </section>
    </section>
  </body>
</html>
