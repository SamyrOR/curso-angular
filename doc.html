<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Angular!!</title>
  </head>
  <body>
    <section>
      <h1>Angular</h1>
      <p>Framerwork front-end desenvolvido entre Google e Microsoft</p>
    </section>
    <section>
      <h1>Introdução</h1>
      <p>Aulas 1 a 8</p>
      <section>
        <h1>Web Components</h1>
        <p>
          O angular funciona com angular components, que nada menos nada mais
          são components HTML, desenvolvidos em partes separadas e organizadas
          em conjuntos para exibição na página
        </p>
        <p>Um só componente pode conter outros components etc</p>
        <p>
          Por convenção, para criação de components, devemos cirar a pasta do
          component,e o arquivo .component.ts, que é o TS do nosso component. E
          o component, deve unica e exclusivamente conter código de iteração com
          o template, código de iteração com bancos de dados e apis devem ser
          criados em serviçes
        </p>
        <p><b> meu-primeiro.component.ts</b></p>
        <p>
          Dentre deste arquivo . component, vamos importar o Component do
          angular ' <b> import { Component } from '@angular/core '</b>
        </p>
        <p>
          Logo em seguida usamos o decorator do component e passamos como
          parametros o seletor, o template em caso de template inline, o
          templateUrl em caso de arquivo HTML, e o styleUrl em caso de arquivo
          css. ficando
        </p>
        <p>
          <b> @Component</b>({ selector: 'meu-primeiro-component', template: `
          código html`, styleUrl: ['./pasta/do/arquivo.css]'})
        </p>
        <p>
          E logo em seguida, como se trata de um decorator devemos informar a
          classe
        </p>
        <p>export class MeuPrimeiroComponent{ código da classe}</p>
        <p>
          Após isto, para utilizarmos na página principal da nossa aplicação,
          devemos importar o nosso component, no arquivo '
          <b> app.module.ts</b> ', após importa-lo, devemos declara-lo no
          decorator <b> @NgModule </b>no array da chave ' declarations:
          [AppComponent, MeuPrimeiroComponent],
        </p>
        <p>
          Então sim, podemos adicionar a tag informada em selector do nosso
          component no arquivo html principal da nossa aplicação o '
          app.component.html '
        </p>
        <p>
          Tambem podemos e devemos utilizar o CLI para criação do component de
          forma dinamica, basta digitar no terminal '<b>
            ng g c nome-do-component</b
          >', que o próprio angular se encarrega de gerar os arquivos e o import
          no @NgModule do nosso app.module.ts
        </p>
        <p>
          <a href="https://angular.io/api/core/Component"
            >Documentação do components</a
          >
        </p>
        <p><strong> Introdução: Hello, world! - Aula 3</strong></p>
      </section>
      <hr />
      <section>
        <h1>Modules</h1>
        <p>
          Outra poderosíssima ferramenta do angular, e o seu modo de produção
        </p>
        <p>
          Com modulos, podemos separar partes do código, como um modulo só para
          login, outro apenas para produtos, etc.
        </p>
        <p>
          Evitando assim congestionar o modulo principal da nossa aplicação o
          <b>AppModule</b>, dentro do modulo principal, temos o
          <b>bootstrap:</b> importado apenas nele, que significa qual a modulo
          principal irá puxar toda a aplicação, tambem o <b>BrowserModule</b>,
          do qual prepara a aplicação para ser rodada em um browser, há tambem o
          <b>FormsModule</b>, utilizado em formulários, e o
          <b>HttpModule</b> que permite utilizarmos as diretivas https, para
          requisição ajax. Todos estes itens estão dentro do decorator
          <b>@NgModule</b>, há tambem a chave do <b>providers</b>, que é
          responsável pelos serviços que desejamos importat.
        </p>
        <p>
          Podemos criar um module com o comando
          <b> ng c m nome-do-module </b> via cli, irá criar a pasta com o nome
          do module e o .module.ts, este module tambem está acompanhado do
          decorator <b>@NgModule</b>, ao ser criado pelo cli tambem ja irá ser
          importado nos imports do modulo principal, dentro dos nossos features
          modules, que são os módulos de funcionalidades, podemos ter vários
          components sendo importado nesses módulos e tambem exportados na chave
          do exports, ao ser exportado o component dentro do feature module
          poderá ser utilizado no template que está sendo importado o nosso
          module.
        </p>

        <p>
          Após criar o nosso module, o component do module e tambem exportar o
          component do module, podemos criar outros components filhos, que podem
          ser utilizados no component do module, porem nao em outros components,
          criando assim components de forma privada.
        </p>
        <h2>Module principal</h2>
        <p>@NgModule ({</p>
        <p>declarations: [declaração dos components aqui]</p>
        <p>imports: [declaração de outros modules aqui]</p>
        <p>providers: [declaração dos services aqui]</p>
        <p>bootstrap: [component principal da aplicação]</p>
        <h2>Feature module</h2>
        <p>@NgModule ({</p>
        <p>imports: [declaração de outros modules aqui]</p>
        <p>declarations: [declaração dos components aqui]</p>
        <p>exports: [export do component principal]</p>
        <p><strong> Introdução: Módulos (ngModule) - Aula 5</strong></p>
      </section>
      <hr />
      <section>
        <h1>Template</h1>
        <p>
          O template é o código HTML do nosso component, pode ser escrito inline
          na chave <b>template:`código html`</b> mas por convenção deve ser
          utilizado assim apenas em casos em que o template tenha no máximo até
          3 linhas
        </p>
        <p>
          Caso ultrapasse isso deve ser utilizado a chave
          <b>templateUrl:[./caminho/do/html.html]</b>
        </p>
        <p>
          No nosso template, podemos referenciar variáveis com
          <b>interpolação {{variável}}</b>, a variável deve ser declarada dentro
          da nossa classe do component com type anotation
        </p>
        <p>Tambem podemos usar diretivas como ngFor, ngIf como em ejs</p>
        <p>
          Podemos tambem definir variável de escopo do template, adicionando um
          # na frente e logo em seguida um nome #variável, sedo possível
          acessa-la de qualquer lugar no template
        </p>

        <p><b> Introdução: Template - Aula 6</b></p>
      </section>
      <hr />
      <section>
        <h1>Serviços (Services) e Injeção de dependência (DI)</h1>
        <p>
          Os serviços, contem todo o código que procura e recebe informações
          externas a aplicação, como em bancos de dados e apis
        </p>
        <p>
          É um classe simples com o decorator <b>@Injectable()</b>, que permite
          que o serviços seja utilizado em injeção de dependência.
        </p>
        <p>
          Dentro da classe teremos métodos normais como em uma classe com a
          lógica do código, e para utilizar como DI, devemos declarar no
          constructor da classe e que desejamos receber o service, geralmente
          como private.
        </p>
        <p><b> Introdução: Services e Injeção de dependência - Aula 7</b></p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Data binding</h1>
      <p>Aulas da 9 a 11</p>
      <p>
        Em Data binding que é o como variáveis e métodos que retornam algum
        valor, podem se comunicar com o template (html) mostrando na tela o
        valor.
      </p>
      <p>Temos 4 tipos de binding em angular, são eles:</p>
      <p>
        <b>Interpolation</b>: {{valor}}; usado quando desejamos mostrar o valor
        de algum atributo do component.. a informação vai do component para o
        template.
      </p>
      <p>
        <b>One-way data binding: [propriedade]="valor": </b> Quando temos alguma
        tag no HTML que tem propriedades, podemos definir o valor da própriedade
        com algum atributo da classe como em uma tag img temos a propriedade src
        e fazemos o property binding como [width] = "valor"..a informação vai do
        component para o template
      </p>
      <p>
        <b>Event binding: (evento)="handler";</b> quando interagimos com a
        lógica do component através do template.
      </p>
      <p>
        <b>Two-way data binding: [(ngModel)]="propriedade";</b> quando
        conseguimos tanto interagir com o template quanto com a lógica do
        component
      </p>
      <hr />
      <section>
        <h1>Property binding e Interpolação</h1>
        <p>
          Interpolation permite adicionar valores do código TS para o template
        </p>
        <p>
          Já o property binding permite adicionar valores as tags HTML que
          possuem propriedades
        </p>
        <p><b> Data Binding: Property binding e Interpolação - Aula 9</b></p>
      </section>
      <hr />
      <section>
        <h1>Class e Style binding</h1>
        <p>
          Podemos usar tambem o property binding para definir classes com
          valores, e o style binding para definir estilos tambem com o property
          binding.
        </p>
        <p><b>[class.nome-da-classe]="valor"</b></p>
        <p><b>[style.propriedade]="valor"</b></p>
        <p><b> Data Binding: Class e Style binding - Aula 10</b></p>
      </section>
      <hr />
      <section>
        <h1>Event binding</h1>
        <p>Para utilizarmos event binding é simples:</p>
        <p>
          <b>(evento)="lógica()"</b> basta adicionar o evento entre parênteses
          como click, mouseover,etc... e o método a ser chamado do component
          passando ou não parâmetros
        </p>
        <p>Importane: podemos capurar o evento com $event</p>
        <p><b> Data Binding: Event Binding - Aula 11</b></p>
      </section>
      <hr />
      <section>
        <h1>Two-way data binding</h1>
        <p>
          Com o two-way data binding, conseguimos tanto altera o valor no
          template como tambem no component, sendo muito útil, sua sintaxe é
          simples:
        </p>
        <p>
          <b> [(ngModel)]="atributo"</b> Alterando em tempo real o o template e
          o componet
        </p>
        <p>
          Devemos nos atentar caso estejamos utilizando o ngModel em um feature
          module, pois devemos importar o FormsModule, ja que o ngModel é uma
          diretiva do FormsModule
        </p>
        <p><b> Data Binding: Two-way data binding - Aula 12</b></p>
      </section>
      <hr />
      <section>
        <h1>Input Property</h1>
        <p>
          Quando usamos components dentro de outros componentes, e necessitamos
          passar informações para esse outro component, podemos utilizar o input
          property:
        </p>
        <p>
          <b> < component [propriedade]="atributo" > < component ></b>, isso
          dentro da tag do component alvo, e no nosso component.ts devemos
          declarar o atributo com o decorator @Input(), que pode receber como
          parâmetro uma string para expor o atributo com o nome desejado.
        </p>
        <p>
          Quando informamos um valor e não um atributo, nao precisamos utilizar
          as chaves: <b>propriedade="valor"</b>
        </p>
        <p>
          A nivel de curiosidade, podemos declarar os inputs em um array dentro
          do @Component, com a chave inputs: [], e dentro do array informar o
          nome dos atributos a receberem inputs, porem por convenção devemos
          utilizar o decorator.
        </p>
        <p>
          Não podemos esquecer de realizar o import do Input de dentro do
          angular/core
        </p>
        <p><b> Data Binding: Input Property - Aula 13</b></p>
      </section>
      <hr />
      <section>
        <h1>Output Property</h1>
        <p>
          Assim como podemos passar valores para um component filho, podemos
          transmitir informações do component filho para o component pai
        </p>
        <p>
          Devemos criar um evento no component filho com
          <b>meuEvento = new EventEmitter</b>(não esquecer de importa-lo) um
          novo evento, e tambem utilizar o decorator <b> @Output()</b> (tambem
          não esquecer de importa-lo), para exportar o evento.
        </p>
        <p>
          Após isso, podemos utilizar o evento criado:
          <b>meu-evento.emit(valor), em qualquer método</b>
        </p>
        <p>
          No elemento pai, devemos observar o evento, e capturar o valor com um
          método no elemento pai
        </p>
        <p>
          < elemento-filho <b> (meuEvento)="onMeuEvento(valor)" > </b> <
          elemento-filho >
        </p>
        <p>
          E com a captura do valor com um método no elemento pai, podemos
          manipular o valor
        </p>
        <p><b> Data Binding: Output Property - Aula 14</b></p>
      </section>
      <hr />
      <section>
        <h1>Ciclo de vida do component</h1>
        <p>
          São os estágios que os componentes passam, sendo eles por ordem de
          execução:
        </p>
        <p><b>constructor</b> construtor do component</p>
        <p>
          <b>ngOnChanges</b>Executado quando há mudanças no component, altamente
          recomendado para elementos que utilizam input property
        </p>
        <p>
          <b>ngOnInit</b>Quando o component é inicializado, altamente
          recomendado para components que não tem property binding e para
          elementos que necessitam de conexão com algum meio externo
        </p>
        <p><b>ngDoCheck</b>A cada ciclo de verificação de mudanças</p>
        <p>
          <b>ngAfterContentInit</b>Depois que o conteúdo externo é inserido na
          view
        </p>
        <p>
          <b>ngAfterContentChecked</b>A cada verificação do conteúdo inserido
        </p>
        <p><b>ngAfterViewtInit</b>Depois que todo a view é carregada</p>
        <p>
          <b>ngAfterViewtChecked</b>A cada verificação de mudança no view do
          component
        </p>
        <p>
          <b>ngOnDestroy</b>Quando a diretiva, pipe, service, component é
          destruído. Util para finalizar um observable.
        </p>
        <p>
          Todos devem ser implementados na classe e importados do @angular/core
        </p>
        <p><b> Data Binding: Ciclo de vida do component - Aula 15</b></p>
      </section>
      <hr />
      <section>
        <h1>Acesso ao DOM e o Template com ViewChild</h1>
        <p>
          Quando declaramos uma váriavel local no template com o #, podemos
          acessa-la dentro do component, atribuindo a uma variável com o
          decorator <b> @ViewChild()</b> que tambem deve ser importado, e
          passando o nome da variável do template como parâmetro pra o ViewChild
        </p>
        <p>
          <b>@ViewChild('variavelTemplate') variávelComponent: ElementRef</b>
          Devemos declarar a variável do component que recebe o viewchild como
          <b>ElementRef</b> ( que tambem deve ser importado), nele contem o
          atributo nativeElement, que retorna o elemento nativo do template, e
          através dele podemos recuperar valores e etc
        </p>
        <p>
          <b>
            Data Binding: Acesso ao DOM e o Template com ViewChild - Aula 16</b
          >
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Angular CLI</h1>
      <section>
        <h1>Instalação e criação de projetos</h1>
        <p>
          Para instalar o Angular CLI, devemos ter o nodejs e o npm instalado,
          funciona acima da versão 4.0
        </p>
        <h3>Comandos Angular CLI:</h3>
        <section>
          <p><b>ng init</b> inicia um projeto angular no diretório</p>
          <p>
            <b>ng new my-app</b> inicia um projeto criando a pasta e instalando
            todas as dependências
          </p>
          <p></p>

          <p>
            <b>ng serve</b> serve o nosso projeto ao browser para que possamos
            ve-lo pelo navegador
          </p>
          <b> Angular CLI: Instalando e criando projetos - Aula 17</b>
        </section>
        <section>
          <h3>Gerando as classes do angular</h3>
        </section>
        <p>
          <b>ng g</b> este comando, o generate é o que gera nossas classes com
          os nomes e arquivos e ja toda a estrutura de acordo com a classe
          gerada com o melhor padrão para o angular
        </p>

        <ul>
          <li>
            <b>ng g component meu-component</b>; gera um component com toda a
            sua estrutura
          </li>
          <li>
            <b>ng g service meu-servico</b>; gera um servico com toda a sua
            estrutura
          </li>
          <li>
            <b>ng g directive minha-diretiva</b>; gera uma diretiva com toda a
            sua estrutura
          </li>
          <li>
            <b>ng g pipe meu-pipe</b>; gera um pipe com toda a sua estrutura
          </li>
          <li>
            <b>ng g class minha-classe</b>; gera uma classe com toda a sua
            estrutura
          </li>
          <li>
            <b>ng g interface miha-interface</b>; gera uma interface com toda a
            sua estrutura
          </li>
          <li>
            <b>ng g enum meu-enum</b>; gera um enum com toda a sua estrutura
          </li>
        </ul>
        <b> Angular CLI: ng generate - Aula 18</b>
      </section>
      <section>
        <h1>Usando pre-processadores</h1>
        <p>
          Para utilizar pre processadores como sass, less, stylus, ao iniciar o
          projeto o próprio CLI, questiona qual extensão desejamos utilizar
        </p>
        <p>
          Caso ja tenhamos um projeto iniciado, podemos alterar com o comando
          <b>ng set defaults.styleExt scss</b>, com a extensão desejada, assim
          todo novo component criado utilizara a nova extensão, mas nao altera a
          extensão de components já gerados
        </p>
        <b> Angular CLI: Pre processadores com angular - Aula 19</b>
      </section>
      <section>
        <h1>lint, test, e2e</h1>
        <ul>
          <li>
            <b>ng lint</b> serve para fazer o lint do nosso app parar verificar
            se está de acordo com o style guide do angular, muito util!
          </li>
          <li>
            <b>ng test</b> executa todos os arquivos .spec.ts do nosso app, e
            roda todos os testes, os teste são realizado por <b> jasmine</b> e
            interpretado pelo <b> karma</b>
          </li>
          <li>
            <b>ng e2e</b> realiza teste end to end da aplicação com o
            protractor, (teste de integração)
          </li>
        </ul>
        <b> Angular CLI: ng lint, teste, e2e - Aula 20 </b>
      </section>
      <section>
        <h1>Gerando build de produção</h1>
        <p>Para gerar build de desenvolvimento e produção temos:</p>
        <ul>
          <li>
            <b>ng build --dev</b>; gera a pasta dist com os arquivos utilizados
            em produção, porem ainda legíveis e indentados, útil para debug
          </li>
          <li>
            <b
              >ng build --prod; gera a pasta dist com os arquivos de produção,
              completamente minificados e ilegíveis, apenas o código funcional
              para a aplicação</b
            >
          </li>
        </ul>
        <b> Angular CLI: Gerando build de produção - Aula 22 </b>
      </section>
      <hr />
      <section>
        <h1>Instalando bibliotecas externas</h1>
        <p>
          Junto com o angular, podemos instalar bibliotecas externas de diversas
          formas
        </p>
        <p>
          Informando o caminho dos styles e scripts direto no arquivo
          <b>angular.json</b>
        </p>
        <p>
          Direto no arquivo index.html ou style.css ( não recomendável, apenas
          para fontes do google)
        </p>
        <p>
          E tambem instalando através do npm e importando direto no modulo
          principal, ou nos módulos que vamos utilizar.
        </p>
        <b> Angular CLI: Instalando bibliotecas externas - Aula 23 </b>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Diretivas</h1>
      <p>
        <b>Diretivas estruturais</b>Interagem com a view e modificam o DOM ou o
        HTML(*ngFor, *ngIf)
      </p>
      <p>
        <b>Diretivas de atributos</b>Interagem com com o elemento em que foram
        aplicadas (ng-class, ng-style)
      </p>
      <p>
        Muito importante, devemos importar o CommonModule para o modulo dos
        components em que vamos utilizar as diretivas nativas
      </p>
      <hr />
      <section>
        <h1>*ngIf</h1>
        <p>
          O *ngIf funciona de forma similar ao if else do JS normal, apenas muda
          a sintaxe, atribuímos ao como propriedade da tag HTML a palavra
          reservada <b> *ngIf="código"</b>
        </p>
        <p>
          Devemos ficar atentos, pois o ngIf alterado o DOM e pode ser custoso,
          então sempre que possível (em árvores pequenas do DOM), podemos e
          devemos utilizar o [hidden], pois é menos custoso a performance
        </p>
        <b> Diretivas: ngIf - Aula 25 </b>
      </section>
      <hr />
      <section>
        <h1>*ngSwitch, ngSwitchCase, ngSwitchDefault</h1>
        <p>Tambem funcionando de forma similar ao switch case do JS</p>
        <p>definimos em uma tag pai o <b> [ngSwitch]="variável"</b></p>
        <p>
          nos elementos filhos, usamos o <b>*ngSwitchCase="valor1"</b>, e o
          código dentro da tag
        </p>
        <p>
          e para valores padrão definimos o <b>*ngSwitchDefault</b> e o valor a
          ser exibido tambem dentro da tag
        </p>
        <b> Diretivas: ngIf - Aula 26 </b>
      </section>
      <section>
        <h1>*ngFor</h1>
        <p>
          Outra diretiva nativa muito ultio no caso de iteração com arrays,
          basta adicionar o <b>*ngFor="let item of array"</b> e dentro da tag
          HTML interpolar com a váriavel local criada {{item}}.
        </p>
        <p>
          Podemos tambem utilizar o index adicionando <b>, let i = index </b>,
          logo após o array no *ngFor
        </p>
        <b> Diretivas: ngFor - Aula 27 </b>
      </section>
      <hr />
      <section>
        <h1>Sobre o * e template</h1>
        <p>
          Quando utilizamos o * antes da diretiva, quer dizer, que por baixo dos
          panos, o angular está criando uma tag template e como property binding
          informando a nossa diretiva
        </p>
        <b> Diretivas: Sobre o * e template - Aula 28 </b>
      </section>
      <hr />
      <section>
        <h1>[ngClass]</h1>
        <p>
          O <b>[ngClass]</b> substitui em casos de verificação para muitas
          classes, o class binding, sendo possível com o ngClass retornar um
          objeto, com a chave entra aspas e o seu valor como a condição
        </p>
        <p>[ngClass]="'class: condição'"</p>
        <b> Diretivas: ngClass - Aula 29 </b>
      </section>
      <section>
        <h1>[ngStyle]</h1>
        <p>
          Funcionar de forma idêntica ao [ngClass], porem com atributos de
          estilo, e com condicionais ternarias
        </p>
        <p><b>[ngStyle]</b>="{'backgroundColor: (ativo ? 'blue : gray}</p>
        <b> Diretivas: ngStyle - Aula 30 </b>
      </section>
      <hr />
      <section>
        <h1>Elvis operator</h1>
        <p>
          O elvis operator, previne a quebra do código caso o nosso objeto tenha
          uma chave com o valor nulo, havendo o valor nulo ele não é
          interpretado
        </p>
        <p>
          <b>obj.exemplo?.mostrar</b> neste caso temos o objeto, e dentro do
          objeto a chave exemplo, se essa chave não for nula e tiver a chave
          mostrar, ele mostrará, mas se a chave do exemplo for nula e le não é
          exibido
        </p>
        <p><b>Diretivas: Operador Elvis - Aula 31</b></p>
      </section>
      <hr />
      <section>
        <h1>ng-content</h1>
        <p>
          Com o input property conseguimos passar dados através de variáveis
          para o component, com o ng-content conseguimos passar conteúdo HTML,
          através da tag <b> < ng-content > </b> no component que vai receber o
          conteúdo, e no component que irá receber o conteúdo passar a div com a
          class de acordo com o <b> select </b>do ng-content
        </p>
        <p>Component que envia <b>< div class="titulo">Titulo enviado</b></p>
        <p>
          Component que recebe
          <b>< ng-content select=".titulo"></b>
        </p>
        <p>E será exibido o conteúdo de acordo com o enviado</p>
        <p><b>Diretivas: ng-content - Aula 32</b></p>
      </section>
      <hr />
      <section>
        <h1>Criando diretivas de atributos customizadas</h1>
        <p>
          Para criar diretivas de atributos (que alteram o estilo do elemento)
          podemos gerar uma diretiva pelo cli <b>ng g d nome-diretiva</b>
        </p>
        <p>
          Após a criação teremos o decorator <b> @Directive</b>, e como
          parâmetro o <b>selector</b> que vai ser o nome da diretiva dentro da
          tag, , para referenciarmos o elemento em que a diretiva foi inserida,
          devemos importar o <b>ElementRef</b>, e para manipular o elemento
          devemos importar e utilizar o <b>Renderer2</b>
        </p>
        <p>
          Tanto o ElementRef quanto Renderer2 devem ser importados como injeção
          de dependência no constructor com
          <b>private _elementRef: ElementRef</b> e
          <b>private _renderer: Renderer2</b>
        </p>
        <p>
          O após criar o atributo recebendo o ElementRef, temos que acessar o
          elemento dentro do atributo nativeElement, passando para o _renderer
        </p>
        <p>
          No renderer, temos diversos métodos, passamos no
          <b
            >.setElementStyle(this._elementRef.nativeElement, propriedadeCSss,
            valor-da-propriedade)</b
          >
        </p>
        <p>
          E está criado a nossa diretiva, bata utiliza-la dentro da tag do
          elemento a ser modificado
        </p>
        <p><b>Diretivas: Criando uma diretiva de atributo - Aula 33</b></p>
      </section>
      <hr />
      <section>
        <h1>HostListener e HostBinding</h1>
        <p>
          <b>HostListener</b> escuta eventos na tag da qual a diretiva foi
          inclusa
        </p>
        <p>
          <b>HostBinding</b> permite a associação de um atributo ou classe CSS,
          para uma variável
        </p>
        <p>
          Ambos devem ser importados do angular core, e utilizados com decorator
          o decorator de mesmo nome, em <b>@HostListener</b> passamos o evento
          como parâmetro e em seguida o método a ser executado
        </p>
        <p><b>@HostListener('evento') metodo() {lógica do método}</b></p>
        <p>
          No
          <b
            >@HostBinding('class' ou 'style.propriedade')
            variável-para-o-binding</b
          >
        </p>
        <p>Ambos utilizados de forma conjunta são extremamente poderosos</p>
        <p><b>Diretivas: HostListener e HostBiding- Aula 34</b></p>
      </section>
      <hr />
      <section>
        <h1>Input e property binding</h1>
        <p>
          Podemos utilizar inputs com property binding tambem nas diretivas, e
          tambem conseguimos pela inteligência do angular, criar inputs com o
          mesmo nome da nossa diretiva <b>[diretiva]="'valor'"</b>
        </p>
        <p><b>Diretivas: Input e Property Binding - Aula 35</b></p>
      </section>
      <hr />
      <section>
        <h1>Criando diretiva de estrutura</h1>
        <p>
          Para criar diretivas de estrutura como um ng-else, devemos tambem
          utilizar o Input property
        </p>
        <p><b>@Input() set nome(condicao:boolean){ lógica } </b></p>
        <p>
          Junto com o <b>TemplateRef</b> que referencia o template, e o
          <b>ViewContainerRef</b>, que é o responsável pela criação do template
          na view com .createEmbeddedView(this._templateRef)
        </p>
        <p><b>Diretivas: Criando diretiva de estrutura - Aula 36</b></p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Services (Serviços)</h1>
      <p>
        Os services são os responsáveis por toda a lógica do negócio da
        aplicação, sempre será os services que farão a comunicação com os
        servidores back end para aquisição e tratamento de dados, os components
        são responsáveis apenas pela exibição dos dados
      </p>
      <p><b>Serviços: Introdução a Serviços- Aula 37</b></p>
      <hr />
      <section>
        <h1>Criando um serviço</h1>
        <p>
          Para criar um serviço basta mandar no cli o comando
          <b>ng g s service-name</b>
        </p>
        <p><b>Serviços: Criando um serviço- Aula 38</b></p>
      </section>
      <hr />
      <section>
        <h1>Como usar serviço em um component + Injeção de dependência</h1>
        <p>
          Para utilizarmos o serviço gerado em um component, devemos através da
          injeção de dependência, devemos importar o service no component, criar
          um atributo no component com o nome e o type do service, no construtor
          devemos passar como parâmetro um atributo private com o nome do
          <b> private _nomeService: NomeService</b>
          serviço e o tipo do serviço , e dentro do construtor iniciar o outro
          atributo recebendo o valor do atributo privado
          <b> this.nomeService = this._nomeService</b>
        </p>
        <p>
          E dentro do ngOnInit(){} que é executado quando o component é
          iniciado, definir as ações do serviço
        </p>
        <p>
          <b
            >Serviços: Injeção de dependência + como usar um serviço em um
            component - Aula 39</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Singleton e várias instâncias</h1>
        <p>
          Quando criamos um service, ele é importado no app modulo, e todo
          component tem acesso ao service. Para que apenas alguns components
          tenham acesso ao service, o mesmo deve ser declarado nos features
          modules e não no app module, limitando assim o seu escopo
        </p>
        <p>
          Porem mesmo quando isso ocorre, o serviço é instânciado apenas uma
          vez, sendo assim é chamado o singleton, ou seja, uma alteração no
          service muda em toda a aplicação
        </p>
        <p>
          Para que isso não ocorra, podemos instanciar o service diretamente no
          component decorator do component com a chave
          <b>providers: [MeuService]</b>, o mesmo será instânciado tambem no
          component, mas seu uso é exclusivo e qualquer alteração não afeta a
          aplicação global.
        </p>
        <p>
          <b
            >Serviços: Escopo de instâncias de serviços e módulos (singleton e
            várias instâncias) - Aula 40</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Broadcast de eventos</h1>
        <p>
          Quando temos um serviço em diferentes instâncias para que haja
          comunicação entre os componentes devemos emitir eventos com o
          <b>EventEmitter< type ></b>
        </p>
        <p>
          Quando é o component filho, podemos emitir um evento normal, e dentro
          daquela instância ele será executado, porem para ser executado tambem
          em outras instâncias o evento deve ser <b>static</b>, pois quando
          usamos um service, devemos instancia-lo, quando o criamos uma nova
          instância apenas dentro daquela isntância os eventos normais serão
          ouvidos, porem com o <b>static</b>, não é necessário declaração de
          instância para o service.
        </p>
        <p>
          <b
            >Serviços: Comunicação entre componentes usando serviços (broadcast
            de eventos) - Aula 41</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Injetando um serviço em outro</h1>
        <p>
          Para realizarmos está tarefa basta criar o serviço, importa-lo e
          injetar como dependência em outro serviço
        </p>
        <p>
          <b>Serviços: Injetando um serviço em outro serviço - Aula 42</b>
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Pipes</h1>
      <p>
        Pipe são formatadores dos dados, com pipes conseguimos deixar os dados
        muito mais visíveis, utilizamos o pipe com o simbolo do pipe
        <b>| nome-pipe:parametro</b>
      </p>
      <p>
        Os pipes podem ser aninhados e serão executados de acordo com a ordem de
        declaração
      </p>
      <hr />
      <section>
        <h1>Pipes nativos</h1>
        <p>
          <b>| uppercase</b> e <b>| lower case </b>; transforma o texto em
          minúsculo e maiúsculo respectivamente
        </p>
        <p>
          <b>|number:'1.1-2'</b>; formata o número, o primeiro parâmetro são as
          casas de inteiros (antes da vírgula), e .1-2, são as casas decimais de
          tanto até tanto, ou de 1-1 mesmo.
        </p>
        <p>
          <b>| currency:'Moeda':true</b>; transforma o número em moeda, sendo o
          primeiro parâmetro a moeda, e o segundo o símbolo, ou código, etc.
        </p>
        <p>
          <b>| date:'dd-MM-yyy'</b>; formata a data, e passando parâmetro
          formata de acordo com o parâmetros
        </p>
        <p>
          <b>| json</b>; transforma objetos literais javascript em objetos json
        </p>
        <p>
          <b>Pipes: Usando Pipes - Aula 43</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Criando um pipe</h1>
        <p>
          Para criar um pipe, utilizamos o comando <b>ng g p nome-pipe</b> após
          isso será gerado o pipe, e seu nome.
        </p>
        <p>
          A classe do pipe implementa o PipeTransforms, e é dentro do
          <b>transform(value, args)</b> que recebe o valor e argumentos, e
          implementamos a lógica do pipe e retornamos o resultado
        </p>
        <p>
          <b>Pipes: Criando um Pipe - Aula 44</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Aplicando Intercionalização</h1>
        <p>
          Os pipes agem de acordo com o <b>locale</b> (localidade) definido, e
          por padrão o do Angular é en-US, mas podemos alterar o locale para o
          angular trabalhar de acordo com a nossa localidade
        </p>
        <p>
          Para isso podemos utilizar um service, ou injetar direto em providers,
          mas antes, devemos importar o locale
          <b>import localePt from '@angular/common/locales/pt';</b> e o
          <b>import { registerLocaleData } from '@angular/common';</b>, após
          importa-los, devemos registrar o locale
          <b>registerLocaleData(localePt);</b>
        </p>
        <p>
          Só então, vamos ao providers e definimos o objeto
          <b>
            { provide: LOCALE_ID, deps: [MeuServico], useFactory: (meuServico)
            => meuServico.getLocale()}</b
          >
        </p>
        <p>
          <b>Pipes: Aplicando locale nos pipes - Aula 45</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Pipe puro</h1>
        <p>
          O Pipe puro não olha as modificações do valor que é passado como para
          o parâmetro para o método transform
        </p>
        <p>
          Atenção para não utilizar pipes de filtro para arrays, pois o mesmo
          caso esteja com o filtro e seja adicionado um novo item no array, ele
          simplesmente não capta a mudança.
        </p>
        <p>
          <b>Pipes: Criando um pipe puro- Aula 46</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Pipe impuro</h1>
        <p>
          Para transforma um pipe em impuro, basta adicionar <b>pure: false</b>,
          no decorator do pipe. Que o mesmo passará a verificar se o
          <b>value</b> foi modificado.
        </p>
        <p>
          <b>Pipes: Criando um pipe impuro- Aula 47</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Filtro em arrays</h1>
        <p>
          Devemos sempre fazer filtros e order-by por métodos do component, não
          por pipes!!
        </p>
        <p>
          <b>Pipes: Criando um pipe impuro- Aula 47</b>
        </p>
      </section>
      <section>
        <h1>Pipe async</h1>
        <p>
          Quando trabalhamos com dados assíncronos, como em requisições,
          promises e observables, podemos utilizar o pipe <b>| async</b> que irá
          aguardar que o valor esteja disponível para que seja exibido na tela,
          caso contrário, o valor será exibido de forma incorreta
        </p>
        <p>
          <b>Pipes: Pipe Assíncrono- Aula 48</b>
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Rotas</h1>
      <p>
        São através das rotas que nossa aplicação vira uma
        <b>SPA (Single-page aplication)</b> ou seja, podemos navegar entre os
        componentes, ou hashes sem ter que renderizar novamente o nosso
        component, auxiliando bastante o desmpenho.
      </p>
      <p>
        <b>Rotas: Introdução - Aula 49</b>
      </p>
      <hr />
      <section>
        <h1>Configurando rotas simples</h1>
        <p>
          Para utilizar as rotas, quando gerado a aplicação, será questionado
          pelo CLI se usaremos rotas, ao aceitar, ele irá gerar o arquivo
          principal de rota, e gerará a base e importará os modules de acordo,
        </p>
        <p>
          Dentro do arquivo de rota, termos uma
          <b>const routes: Routes = []</b> e é dentro do array que definimos as
          rotas
        </p>
        <p>
          Temos que adicionar um objeto, com chaves de
          <b
            >{ path:'nome-do-caminho'(/caminho), component: NomeDoComponent},</b
          >
          para a base, deixamos o <b>path: ''</b> vazio
        </p>
        <p>
          Dentro do nosso modulo de rotas, tem o decorator do
          <b>@NgModule</b> com uma chave de <b>imports</b> importando o
          <b>RouterModule.forRoot(routes)</b>, o .forRoot, indica que estamos
          importando as rotas para a rota principal da aplicação, caso nossas
          rotas possuam outras rotas, devemos criar outro arquivo de rotas com
          <b>.forChild(routes)</b>
        </p>
        <p>
          Para que a nossa rota seja exibida no component destino, devemos
          utilizar a tag <b>< router-outlet ></b>, e no nosso
          <b>index.html</b> a uma tag dentro do head,
          <b>< base href="/" /></b> que significa que a nossa aplicação começa
          da /, poderíamos adicionar alguma informação e nossa aplicação
          começaria dali. (/info), e apartir disso toda aplicação começa de
          /info
        </p>
        <p>
          <b>Rotas: Configurando rotas simples - Aula 50</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>RouterLink</h1>
        <p>
          Para definir que alguma tag <b>a</b> direcione para nossas rotas,
          dentro da tag adicionamos o <b>routerLink="/caminho"</b>, então será
          redirecionado para a rota informada
        </p>
        <p>
          <b>Rotas: RouterLink: definindo rotas no template - Aula 51</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>RouterLinkActive</h1>
        <p>
          O <b>routerLinkActive="classe"</b> permite adicionar um classe CSS
          quando a rota do link estiver ativa, útil para estilizar links ativos
          em uma navbar
        </p>
        <p>
          <b
            >Rotas: RouterLinkActive: aplicando CSS em rotas ativas - Aula 52</b
          >
        </p>
      </section>
      <section>
        <h1>Definindo um parâmetros em rotas</h1>
        <p>
          Para definirmos rotas dinânimcas com parâmetros, podemos no array de
          rota adicionar,
          <b>{ path: 'cursos/:id', component: CursoDetalheComponent },</b>,
          perceba que há <b>:/id</b>, ou seja, qualquer rota curso com algum
          valor, será interpretado como id a página irá apontar para o component
          correspondente.
        </p>
        <p>
          Para passar o parâmetro no template, devemos usar o <b>routerLink</b>,
          como property binding, passando um array
          <b>[routerLink]="['/caminho', parametro.value]"</b>
        </p>
        <p>
          <b>Rotas: Definindo e extraindo parâmetros de roteamento - Aula 53</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Escutando mudanças nos parâmetros</h1>
        <p>
          Para escutar de forma dinâmica qual o parâmetro inserido, devemos
          importar e injetar o <b>ActivatedRoute</b>, que é uma instância da
          rota ativa, dentro do life cilcly hook <b>ngOnInit()</b> definimos
          através de subscribe que vamos escutar
          <b>this.route.params.subscribe()</b> passando como parâmetro uma arrow
          function <b>params => {this.id = params['id']}</b>
        </p>
        <p>
          <b>Boas práticas</b> ao utilizarmos subscribe do rxjs, devemos
          importar atribuir a uma variável o tipo <b>Subscription</b>, e no life
          cicly hook <b>ngOnDestroy</b> aplicar o <b>unsubscribe()</b>, caso
          contrário ainda ficaríamos inscritos mesmo após o component ser
          destruído
        </p>
        <p>
          <b
            >Rotas: Escutando mudanças nos parâmetros de roteamento - Aula 54</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Redirecionamento via código</h1>
        <p>
          Para tratamento de erros, podemos redirecionar rotas pelos components,
          devemos importar injetar a classe <b>Router</b>, está classe tem
          diversos métodos, porem o de redirecionamento é o
          .navigate(['/caminho'], parâmetro?)
        </p>
        <p>
          <b>Rotas: Rotas imperativas: Redirecionamento via código - Aula 55</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Definindo e extraindo parâmetros de url(query)</h1>
        <p>
          São os parâmetrs de link (url), é uma forma de passar parâmetros
          opcionais para as rotas, (sem ter que altera-las ou criar outra rota)
        </p>
        <p>
          Devemos adicionar um propertyBinding com
          <b> [queryParams]="{chave: valor}"</b>, podendo ser dinâmico
        </p>
        <p>
          Tambem podemos nos inscrever no subscribe do e
          <b>this.route.queryParams.subscribe</b> para passar o valor do query
          params para um atributo, e navegar entre as rotas através de um botão
          passando o navigate com o atributo como valor do query params do
          atributo que recebemos o query params.
          <b
            >this.router.navigate(['/cursos'], { queryParams: { pagina:
            ++this.pagina }, })</b
          >
        </p>
        <p>
          <b>Rotas: Definindo e extraindo parâmetros de url(query) - Aula 56</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Criando um módulo de rotas e módulo de funcionalidades</h1>
        <p>
          Podemos e devemos criar e estruturar nossos projetos com módulos, para
          não poluir o módulo principal <b>app-module.ts</b> nem o module de
          rotas <b>app-routing.module.ts</b>, em cada component que vamos ter
          mais de um component filho, definimos um module, dentro dele todas as
          definições necessária como ja visto antes.
        </p>
        <p>
          Para criar um módulo de rotas, devemos importar e exportar o
          <b>RouterModule</b>, dentro do decorator do <b>@NgModule</b> que
          tambem deve ser importado, muito importe muito importante declarar
          como <b>.forChild(minhaRoute)</b>, declarar a const <b>minhaRoute</b>,
          com o tipo <b>Route</b> e um array de objetos com os paths os
          components e seus imports.
        </p>
        <p>
          Nosso router module, vai ser importado no module do component
          principal, que será importado como module no <b>app.module.ts</b>
        </p>
        <p>
          <b
            >Rotas: Criando um módulo de rotas && Criando um módulo de
            funcionalidades - Aula 57-58</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Rotas filhas</h1>
        <p>
          Para criação de rotas filhas, dentro de um módulo de rotas de
          funcionalidade, adicionamos na rota principal a chave
          <b>children: []</b>, passando dentro do array, todas as outras rotas
          filhas, sendo assim será renderizado junto com a rota pai.
        </p>
        <p>
          Não esquecer da tag <b> < router-outlet > </b>dentro do component pai
        </p>
        <p>
          <b>Rotas: Rotas filhas - Aula 61</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Lazy Loading</h1>
        <p>
          Quando não definimos o lazy loading nas rotas, carregamos toda a
          aplicação de uma vez, o que deixa nossa aplicação mais pesada,
          seguindo os padrões de boas práticas, temos a nossa aplicação
          modularizada, e quando há rotas filhas, podemos carregar com o
          <b>lazy loading</b>, que nos permite carregar os arquivos necessários
          de acordo com a navegação, deixando assim a aplicação mais leve.
        </p>
        <p>
          Sintaxe
          <b
            >{ path: 'minhaRota', loadChildren: () =>
            import('./rota/minhaRota.module').then(m => m.MinhaRotaModule) }</b
          >
        </p>
        <p>
          Assim, a aplicação modularizada será carregada de acordo com os
          arquivos necessários para a navegação
        </p>
        <p>
          Importante não esquecer de apagar os imports e declaração do modulo no
          modulo principal da aplicação e nenhum outro lugar da aplicação, e
          tambem dentro do routing do component, declarar o caminho principal
          apenas com <b>''</b>, pois já será declarado dentro do
          <b>app-routing</b>
        </p>
        <p>
          <b>Rotas: Lazy Loading - Aula 62</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Tela de login e como não mostrar o navbar</h1>
        <p>
          Para que possamos autenticar um usuário, precisamos de um service,
          dentro do service há a lógica de autenticação, e caso o usuário seja
          autenticado, através do router podemos redirecionar a página para o
          inicio, caso o usuario ainda não esteja logado, podemos esconder a
          barra de navegação, para isso, criamos um
          <b>event emitter boolean</b>, e adicionamos no autenticador do
          usuário, caso o usuário seja autenticado, podemos emitir um true, e
          caso não emitimos o false.
        </p>
        <p>
          Dentro do component que possui a navbar, definimos uma variável
          subscrita no evento criado, e no template, adicionamos um if, se a
          variável for true, mostra a nav bar, caso contrario não será exibida.
        </p>
        <p>
          <b>Rotas: Tela de login e como não mostrar o NavBar - Aula 63</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Guarda de rota CanActivate</h1>
        <p>
          Podemos colocar guarda nas rotas, para no exemplo mais prático, o
          usuário não esteja autenticado, não consegui acessar páginas do site
          que apenas usuários autenticados conseguem acessar.
        </p>
        <p>
          Para isso, geramos o guarda de rota com <b>ng g guard nome-guarda</b>,
          após gerado, o guarda ja terá toda a estrutura necessária, devemos
          apenas desenvolver a lógica denro do nosso servico autenticador, um
          metodo boolean para que caso o usuário esteja autenticado retorn true,
          e caso não, retorne false, importamos e aplicamos esse metodo dentro
          do guarda, e caso seja verdadeiro retorna true e caso falso direciona
          o usuário para a página de autenticação
        </p>
        <p>
          Para que o guarda funcione precisamos adicionar a chave com o tipo do
          guarda, ex <b>canActivate</b> e o qual o guarda será usado,
          <b>canActivate:[AuthGuard]</b>, então a rota passará a ser protegida!
        </p>
        <p>
          <b>Rotas: Usando guarda de rotas: CanActivate- Aula 64</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>CanActivateChild</h1>
        <p>
          O Procedimento basicamente é o mesmo do guarda <b>CanActivate</b>,
          para casos que um usuário comum não possa acessar alguma rota, a
          protegemos com o guard e colocamos a lógica, com o Child é para rotas
          filhas, ou seja, podemos alem do guarda principal ter um guarda para
          as rotas filhas
        </p>
        <p>
          Para isso criamos um guard <b>CanActivateChild</b> e adicionamos ele
          ou no escopo global, para que nem a rota seja acessada, ou apenas no
          escopo da rota, dentro do seu module e seu routing module, para que
          somente as suas filhas não seja acessada
        </p>
        <p>
          <b>Rotas: Usando guarda de rotas: CanActivateChild - Aula 65</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>CanDeactivate</h1>
        <p>
          O guarda de rota <b>CanDeactivate</b> nos permite ao contrario do
          canActivate, que permite o acesso via autenticação, o
          <b>CanDeactivate</b> pode resguardar o usuário de sair da rota sem
          querer, muito útil para preenchimento de formulários e páginas que
          precisam de edição, e caso o usuário saia perca tudo, o
          <b>CanDeactivate</b> pode ser programado para que haja um confirmação
          para que o usuário não saia sem perder informações.
        </p>
        <p>
          Para isso criamos a rota do <b>CanDeactivate</b> e temos que passar
          para a rota, o <b> component como tipo</b> e na chave
          <b>component</b>, após isso, importar no provider modulo que será
          usado e adicionar a chave <b>canDeactivate</b> com o guarda dentro do
          array, <b>canDeactivate: [MeuDeactivateGuard]</b>
        </p>
        <p>
          E como o deactivate tem acesso ao component, podemos dentro do
          component definir a lógica de confirmação e retornar dentro do guarda
        </p>
        <p>
          <b>Rotas: Usando guarda de rotas: CanDeactivate - Aula 66</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Deixando o CanDeactivate genérico</h1>
        <p>
          Quando utilizamos o <b>CanDeactivate</b> devemos passar um component
          como tipo e na chave component, porem fica muito restrito, caso temos
          mais de um formulário para utilizar o guarda
        </p>
        <p>
          Para resolver este impasse, podemos criar uma interface, com um método
          especifico, que todo component que desejar usar o guarda, deve
          implementar a interface, e dentro do nosso guarda, devemos no tipo e
          no component, informar a interface
        </p>
        <p>
          <b
            >Rotas: Usando guarda de rotas: CanDeactivate com interface
            genérica- Aula 67</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Resolver: carregando dados da rota antes da rota ser ativada</h1>
        <p>
          Com um <b>resolver</b> podemos carregar dados da rota, antes mesmo
          dela ser renderizada, pois os dados em si, só são carregados
          posteriormente, muito útil em grandes aplicação com requisições
          assíncronas
        </p>
        <p>
          Para utilizar o resolver, primeiramente criamos o arquivo, é muito
          similar a uma rota, e dentro do
          <b>implementes Resolve< objeto ></b> passamos a interface do objeto
          que desejamos carregar como tipo, e dentro do próprio resolver fazemos
          a lógica para recuperar e retornar o objeto
        </p>
        <p>
          Dentro do <b>routing-module</b> adicionamos mais um atributo a rota o
          <b>resolve: {nomeObjeto: MeuResolver}</b>, atenção, o primeiro item é
          o nome que vai ser possível recuperar o objeto dentro do component
          através do
          <b>this.route.data.subscribe((obj) => { this.aluno = obj.aluno;</b>
        </p>
        <p>
          <b
            >Rotas:Resolve: carregando dados antes da rota ser ativada- Aula
            68</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>CanLoad</h1>
        <p>
          Ao acessar nossa aplicação, após algum acesso, carregamos o modulo do
          arquivo, quando não temos mais acesso, pode ocorrer que o arquivo seja
          carregado mesmo sem o acesso
        </p>
        <p>
          Para proteger ainda mais o código da nossa operação, podemos utilizar
          o <b>CanLoad</b>, tambem é um guarda de rotas, que pode verificar se o
          usuário tem acesso ou não, e caso não tenha não carrega o arquivo.
          Muito similar a um <b>AuthGuard com CanActive</b>
        </p>
        <p>
          E para utiliza-lo tambem adicionamos uma chave na rota com
          <b>canLoad: [CanLoadGuard]</b>
        </p>
        <p>
          Podemos tambem utilizar mais de um método de rotas, dentro de um
          arquivo de rotas, e tambem devemos utilizar a rota <b>canLoad</b>, nos
          arquivos de rotas que tem lazy-loading
        </p>
        <p>
          <b
            >Rotas: CanLoad: como não carregar o módulo sem permissão - Aula
            69</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Definindo rota padrão e wildcard</h1>
        <p>
          Quando informamos uma página que não existe em nenhum dos nossos
          módulos de rota, na barra de endereço, o angular quebra pois ele
          verifica rota por rota dentro da ordem e quebra se não encontrar
          nenhuma correspondente
        </p>
        <p>
          Para definir uma rota de página não encontrada (capturando qualquer
          rota que não esteja disponível e direcionar para um página de 404),
          basta criar um component para a exibir a página de erro e adicionar a
          rota: <b>{ path: '**', component: PaginaNaoEncontradaComponent }</b>,
          no <b>path:</b> adicionamos <b>**</b> pois equivale a qualquer valor
          que não seja uma das rotas, por isso a rota de vazia de home e a de
          erro devem ser as últimas
        </p>
        <p>
          Para definir uma rota padrão, podemos usar a chave
          <b>redirectTo: '/rota'</b> e o <b>patchMatch: 'full'</b>, o redirect
          indica que ao ser acessada a rota, deve ser redirecionada para a
          informada, e o patchMatch: basicamente informa se deve pegar todo o
          nome da rota, ou somente o prefixo, no exemplo por ser rota vazia deve
          ser full, mas para casos em que temos rotas filhas, usamos
          <b>prefix</b>
        </p>
        <p>
          <b
            >Rotas: definindo rota padrão e wildcard (rota não encontrada) -
            Aula 70</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>HTML5 ou #</h1>
        <p>
          Por padrão, a navegação entre páginas HTML usa apenas a /, porem
          algumas linguagens de back end, podem não reconhecer o padrão e bugar
          a aplicação, o angular nos da a opção de usar #, facilitando assim a
          comunicação com essas linguagens
        </p>
        <p>
          Basta que no import do arquivo de rotas, adicionamos um objeto como
          segundo parâmetro com o <b>{useHash: true}</b>, recebe um boolean
          podendo ser true ou false, no caso true habilitará a hash nas rotas
        </p>
        <p>
          <b>Rotas: Estilo de url: HTML5 ou usando # - Aula 71</b>
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Formulários Template Driven</h1>
      <p>Template Drive vs Data Driven</p>
      <p>
        Os formulários que são <b>template driven</b> sãos os que possuem o
        código e validação dentro do próprio HTML com diretivas, etc, e
        necessitam do ngSubmit para serem enviados
      </p>
      <p>
        Já os formulários <b>data driven</b>, possuem o HTML como esqueleto
        apenas para estrutura do form, porem todo dado é manipulado e tratado e
        validado dentro do component sem a necessidade do ngSubmit, tabem
        chamados de formularios reativos
      </p>
      <p>
        Devemos sempre importar o <b>FormsModule</b> para o modulo em que se
        encontra nosso component que contem o formulario
      </p>
      <p>
        <b
          >Formulários Template Driven: E (template vs data / reativo)
          Introdução - Aula 72</b
        >
      </p>
      <hr />
      <section>
        <h1>Controles ngForm, ngSubmit e ngModel</h1>
        <p>
          Para informamos para o Angular que estamos trabalhando com um form
          template driven, devemos usar criar uma várivale local na tag que
          inicia o form, do tipo que recebe um ngForm <b>#exemplo="ngForm"</b>
        </p>
        <p>
          Para que alguma ação de execução seja excecutada no form, adicionamos
          o event <b>(ngSubmit)="onEnvio(exemplo)"</b> passando o metodo que
          contem a lógica para envio, e o form com a váriavel local criada
        </p>
        <p>
          E para indicar cada elemento do form, adicionamos um a propriedade
          <b>name="nomeDoIput"</b> e o <b>ngModel</b> então nosso form será
          construido com o objeto nomeado e o valor informado
        </p>
        <p>
          <b
            >Formulários Template Driven: Controles ngForm, ngSubmit e ngModel -
            Aula 74</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Iniciando valores com ngModel two-way data-binding</h1>
        <p>
          Para iniciar o form com valores já nele, criar um objeto com os campos
          que desejamos iniciar no component, ja contendo os valores, e dentro
          do form, adicionamos o two-way data-binding dentro no <b>ngModel</b> e
          passamos o objeto e as chaves para o campo
        </p>
        <p>
          <b>[(ngModel)]="meuForm.email"</b> e ele receberá o valor que está
          declarado no component, e como é two-way data-binding, ele receberá o
          valor quando o form for submetido
        </p>
        <p>
          Caso não desejamos que o valor do objeto seja modifciado, podemos
          utilziar apenas o properti bidng
        </p>
        <p>
          <b
            >Formulários Template Driven: Inicializando valores com ngModel
            (two-way data-binding) - Aula 75</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Aplicando validação nos campos</h1>
        <p>
          Dentro do prprio input podemos aplicar validadores para o form, alguns
          do angular são:
        </p>
        <p><b>required</b> o campo é obrigatório</p>
        <p><b>email</b> o valor inserido deve ser um email valido</p>
        <p><b>minLength="2"</b> tamanho minimo do campo</p>
        <p><b>maxLength="3"</b> tamanho máximo do campo</p>
        <p>
          <b>pattern="[a-zA-Z]"</b> define um tipo de validação recebida de uma
          RegEx
        </p>
        <p>
          <b
            >Formulários Template Driven: Aplicando validação nos campos - Aula
            77</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Aplicando CSS na validação nos campos</h1>
        <p>
          O angular, aplica 6 classes para o formulario e cada input de acordo
          com controle:
        </p>
        <p><b>ng-untouched</b> o input não foi visitado</p>
        <p><b>ng-touched</b> o input foi visitado</p>
        <p><b>ng-pristine</b> o valor do input não mudou</p>
        <p><b>ng-dirty</b> o valor do input mudou</p>
        <p><b>ng-valid</b> o input é valido</p>
        <p><b>ng-invalid</b> o input é invalido</p>
        <p>
          Permitindo assim, que através do CSS do component, consigamos alterar
          o CSS do input personalizamos o CSS dela dentro do component.css, e
          caso o input receba a classe <b>ng-invalid</b>, receberá o estilo
          declarado para a classe
        </p>
        <p>
          <b
            >Formulários Template Driven: Aplicando CSS na validação dos campos
            - Aula 78</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Mostrando mensagens de erro de validação</h1>
        <p>
          Com o template driven, para mostrarmos mensagens de erro na tela,
          utilziamos o
          <b>[ngClass]="{'class1' , 'class2', 'class3': validaçãoaqui}"</b>, que
          indica que tais classes serão aplicadas de acordo com a validação,
          podemos validar através dos controles presents no inputs, que possuem
          os memos nomes das classses listadas acima, para isso, tambem devemos
          declarar uma variavel local do input recebendo o ngModel.
          #campoNome="ngModel", assim nos dá acesso ao constroles. e através
          deles conseguimos adicionar as classes, que a maioria das bibliotecas
          CSS possuem.
        </p>
        <p>
          Podemos tambem declarar uma div logo abaixo do input para a declaração
          de um texto caso o input seja invalido
        </p>
        <p>
          <b
            >Formulários Template Driven: Mostrando mensagens de erro de
            validação - Aula 79</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Desabilitando o botão de submit para formulário inválido</h1>
        <p>
          Quando nosso formulário estiver inválido, não queremos que o botão de
          enviar esteja disponível, para isto, bata adicionar a property binding
          <b>[disabled]="form.invalid"</b> passando a validação do do controle
          .invalid da variável local do nosso form, em caso de true o botão não
          será apresentado.
        </p>
        <p>
          <b
            >Formulários Template Driven: Desabilitando o botão de submit para
            formulário inválido - Aula 80</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>*DICA Debugando o Form</h1>
        <p>
          Quando trabalhamos com formulários, para deixar mais pratico o debug
          durante o desenvolvimento, no angular, podemos criar um novo
          component, que recebe um atributo form passado por input, o declaramos
          no component do form a ser debugado através do seu template e passamos
          com property binding o form, para a váriavel que recebe o input,
          dentro do component de debug, declaramos por interpolação os dados do
          form recebido que desejamos verificar como:
        </p>
        <p>Validade do formulario <b>{{form.valid}}</b></p>
        <p>Se foi enviado ou não <b>{{form.submitted}}</b></p>
        <p>
          Valores do form e neste, recebemos um objeto e então usamos o pipe do
          JSON para visualizaçõ do conteudo <b>{{form.value | json}}</b>
        </p>
        <p>
          <b
            >Formulários *DICA Verificando dados do Form no template com JSON-
            Aula 81</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Aninhamento de dados</h1>
        <p>
          Podemos aninhar/agrupar dados do nosso formulario (criar objetos
          dentro de objetos) para facilitar o a busca e separa-los para melhor
          entendimento, e para isto, basta que adicionemos no elemento container
          o
          <b
            >ngModelGroup="nomeDoObjeto" que será criado um objeto e todo o form
            dentro dele faram parte dele, e podem ser aninhado mais de um
            <b>ngModelGroup</b></b
          >
        </p>
        <p>
          <b
            >Formulários: Template Drive: Form groups (agrupando dados) - Aula
            84</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Adicionando evento ao element e recuperando via http o CEP</h1>
        <p>
          Podemos por eventos, passar valores como parâmetros de metodos do
          nosso component, e dentro do component tratar esses valores, como
          realizar um solicitação via http, para um server
        </p>
        <p>
          <b
            >Formulários: Pesquisando endereço automaticamente com CEP - Aula
            85</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Populando campos do form</h1>
        <p>
          Para adicionar de forma automatica um valores para campos dos
          formulários de forma dinamica, ao receber o obejto, devemos receber o
          fomulário e podemos utilizar o <b>.setValue({})</b> passando como
          objeto os campos do form e o valor que irão receber
        </p>
        <p>
          Poremo o <b>setValue()</b> reseta o valor do formulário, se ja havia
          algum campo informado, por isso o uso mais indicado é o
          <b>patchValue({})</b>
        </p>
        <p>
          A forma de utilizar é a mesma, este metodo popula apenas os campos com
          os valores informados, sem alterar outros campos ja preenchidos
        </p>
        <p>
          <b
            >Formulários: Template Driven: Populando campos com setValue e
            patchValue (autocomplete CEP) - Aula 86</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Submeter o formulário</h1>
        <p>
          Para submeter o formulario devemos ter um metodo que receba o
          formulário, dentro dele realizamos as operações com o HTTP post
        </p>
        <p>
          <b>
            onSubmit(form) { this.http .post('https://httpbin.org/post',
            JSON.stringify(form.value)) .subscribe((dados) =>
            console.log(dados)); }</b
          >
        </p>
        <p>
          Neste caso o valor formulário é um objeto javascript e para
          transfora-lo em JSON, que é o mais trabalhado com JS, usamos o metodo
          <b>JSON.stringfy(form.value)</b> e enviamos ao servidor, podemos
          tambem dar subscribe para receber o retorno da requisição se foi
          concluida com sucesso ou não.
        </p>
        <p>
          <b
            >Formulários: Template Driven: Submetendo valores com HTTP POST
            (autocomplete CEP) - Aula 87</b
          >
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Formulários Data Driven</h1>
      <p>
        Os formulários <b>Data Driven</b>, so formulários que todo o código dos
        dados e validação está no próprio component, diferente do
        <b>template driven</b>, sendo o <b>data driven</b> mais usado e
        recomendado por todos para criaçãos dos forms, devido a facilidade de
        manutenção e escalabilidade.
      </p>
      <p>
        <b>Formulários: Data Driven: Introdução - Aula 88</b>
      </p>
      <hr />
      <section>
        <h1>Criando o form com código Angular</h1>
        <p>
          Para criação do formulário, no modulo que comporta o mesmo, devemos
          impotar alem do <b>FormsModule</b> o <b>ReactiveForms</b>, e dentro do
          component criamos a variável que receberá os dados do nosso form.
        </p>
        <p>
          Inicializamos a inclusão dos dados no
          <b>ngOnInit(){this.formulário}</b> podemos indicar que o nosso
          formulário é <b>this.formulario = new FormGroupp ({})</b> que é um
          objeto, e dentro dele, declaramos as chaves do form, e os valores
          recebem um <b>new FormControl(valor)</b>, porem para ser menos
          verboso, caso temos um formulário com muitos dados, podemos injetar o
          <b>FormBuilder </b>como dependência no constructor, e importa-lo no
          component.
        </p>
        <p>
          Com o <b>formBuilder</b> iniciamos o form com
          <b>this.formulario = this.formBuilder.group({})</b> e dentro dele
          declaramos a chave, e o valor agora recebe um array com os parâmetros.
          <b>nome: [valor],</b>
        </p>
        <p>
          <b
            >Formulários: Data Driven: Criando um form com código Angular - Aula
            90</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Sincronizando o temaplate do form, com a variável</h1>
        <p>
          Para atribuir o formulário a váriavel do form e os inputs as chaves do
          formulário, na tag do form, usamos a diretiva
          <b>[formGroup]="formulario"</b> passando a variável do formulário
        </p>
        <p>
          E pera passar os inputs para as chaves, na tag do input, usamos a
          <b>formControlName="nomeDaChave"</b> passamos o nome do modo em que se
          contra no nosso formulárop
        </p>
        <p>
          <b
            >Formulários: Data Driven: Sincronizando HTML com FormGroup - Aula
            91</b
          >
        </p>
      </section>
      <hr />
      <section>
        <h1>Fazendo submit com data driven</h1>
        <p>
          Com o formulário data driven, usamos o event
          <b>(ngOnSubmit)="metodoDeEnvio()"</b> diferente do template driven não
          passamos o formulário, pois ele ja se encontra no component, e dentro
          do component fazemos a lógica do submit, com o this.formulario
        </p>
        <p>
          <b>Formulários: Data Driven: Fazendo bubmit - Aula 92</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Resetando o form</h1>
        <p>
          Para resetar o formulário <b>data driven</b> devemos criar um metodo,
          e dentro dele executar um <b>this.formulario.reset()</b> que reseta
          todos os campos
        </p>
        <p>
          Podemos executar esse procedimento dentro do subcribe e restar quando
          o forumlário é enviado com sucesso, e tambem adicionar algum botão
          para cancelar que o reseta
        </p>
        <p>
          <b>Formulários: Data Driven: Resetando o form- Aula 93</b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Aplicando validação nos campos</h1>
        <p>
          No data driven, para aplicar a validação nos campos, dentro do
          compoenent diretamente no array de valor, importamos o
          <b>Validators</b> tambem do angular forms, podendo ser apenas um
          validação e no caso de mais que uma, passar como array.
        </p>
        <p>
          nome: [ valor,
          <b
            >[ Validators.required, Validators.minLength(3),
            Validators.maxLength(20), ]</b
          >, ],
        </p>
        <p>
          <b
            >Formulários: Data Driven: Aplicando validação nos campos- Aula 94
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>ACesso ao FormControl no HTML para aplicar CSS de validação</h1>
        <p>
          Para aplicar CSS de validação no formulário, de acordo com o seu
          framework, temos as classes, a validação fica no component, nele
          pegamos o campo de acordo com o passado dentro do HTML, passamos como
          string <b>validaCampo('nomeDoCampo')</b>, e dentro component recebemos
          o campo com o <b>this.formulario.get(nomeDoCampo)</b> que tem como
          retorno o o campo, e atraés dele, conseguimos acessar os controls e
          receber o boolean de acordo com a validação
          <b>valid, touched, pristine</b>
          e no HTML temos o <b>[ngClass]={'classe': validaCampo(nomeDoCampo)</b>
        </p>
        <p>
          <b
            >Formulários: Data Driven: Acesso ao FormControl no HTML e CSS de
            validação dos campos - Aula 95
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Agrupando dados</h1>
        <p>
          Com o fomulário reativo, para agrupar dados, declaramos a chave e como
          valor, tambem adicionamos o
          <b>grupo2: this.formBuilder.group({})</b> e passamos dentro do objeto
          os controls que vão pertencencer ao grupo, e atenção que agora os
          atributos do grupo2 devem ser chamados conforme,
          <b>formulario.grupo2.valor1</b>
        </p>
        <p>
          <b
            >Formulários: Data Driven: Form groups (agrupando dados)- Aula 97
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Auto populando com setValue e pathValeu</h1>
        <p>
          Funciona da mesma maneira que o template driven,
          <b>patchValue</b> popula diversos inputs sem afetar outros campos, e o
          setValue é recomendado quando desejamos popular apenas um campo
        </p>
        <p>
          <b
            >Formulários: Data Driven: Autopopulando endereço com CEP (setValue
            e patchValue) - Aula 98
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Verificar campos com o botão submit</h1>
        <p>
          Para realizarmos a verificação do campo quando o submit é clicado, se
          estivar valido realizamos o envio, senão iteramos sobre cada elemento
          do form e verificamos qual está invalido.
        </p>
        <p>
          Para isto criamos um metodo que recebe como parametro o formulario,
          dentro dometodo utilizamos o
          <b>Objecti.keys(formulario.controls).forEach</b> pois assim
          conseguimos iterar sobre cada campo do formularios, ao iterar ,
          adicionamos um <b>.markAsDirty()</b>, pois assim os campos que estão
          invalidos teram a mensagem de err exibida na tela, devemos tambem
          adicionar um
          <b>
            if(campo instanceof FormGroup){invocar o metodo passando o campo}
          </b>
          que caso um dos campos seja um aninhador para outros campos, invocamos
          o metodo que valida passando o campo que aninha os outrs, sendo assim,
          independentemente de termos varios niveis em nosso form, ele será
          validado
        </p>
        <p>
          <b
            >Formulários: Data Driven: Verificar validação dos campos com botão
            submit - Aula 99
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>DRY: Refatorando o código</h1>
        <p>
          Quando temos código que é repetido, devemos criar serviços para o
          mesmo, para evitar repetições, e apatir do angular 6+, dentro dos
          nossos services, temos a chave <b>provideIn: 'root'</b>, que faz com
          que não precisemos declarar mais os services dentro dos
          <b>providers: []</b> dos modules, pois o proprie angular está
          inteligente o suficiente para entender aonde o service está sendo
          importado.
        </p>
        <p>
          <b
            >Formulários: Data Driven: Serviço de consulta CEP + provideIn -
            Aula 100
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Observables e | async</h1>
        <p>
          Sempre que trabalharmos com variáveis que são observables, devemos
          utilizar o <b>| async</b> no template, pois evita data leak
        </p>
        <p>
          <b>Formulários: Data Driven: Combo box simples - Aula 101 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Objeto como value</h1>
        <p>
          Podemos passar como value algum atributo, porem podemos tambem passsar
          um objeto, porem para isso devemos tomar alguns cuidados como:
        </p>
        <p>
          Ao invés de <b>[value]="valor"</b> no <b>optiion</b>, utilizamos o
          <b>[ngValue]="objeto"</b>, e dentro do select, utilizamos o
          <b>[compareWith]="metodoQueRetornaBoolean"</b>, e no nosso metodo,
          fazemos a comparação
        </p>
        <p>
          <b>return obj1 && obj2 ? obj1.nome === obj2.nome : obj1 === obj2;</b>
        </p>
        <p>
          <b
            >Formulários: Data Driven: Combobox com Objeto (ngValue e
            compareWith) - Aula 103
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Seleção multipla em drop down</h1>
        <p>
          Para termos seleções multiplas em tags <b>select</b> basta adicionar
          <b>multiple</b> como proprieade da TAG, e para selecionar mais de um
          item <b>segurar ctrl</b>
        </p>
        <p>
          <b
            >Formulários: Data Driven: Combobox Múltiplo (Select Multiple) -
            Aula 104
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Radio buttons</h1>
        <p>
          Devemos trabalhar com radio buttons, por mais que sejam poucos opções,
          de forma já mais dinâmica pois deixa o código mais interessate, e
          tambem adicionamos um valor padrão ja direto no FormControl do campo.
        </p>
        <p>
          <b
            >Formulários: Data Driven: Radio Button (Botão do tipo Rádio) - Aula
            105
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>FormArrays</h1>
        <p>
          Os FormArrays geralmente são gerados através de métodos, recebemos o
          array como valor, e iteramos ele para ser criado como retorno
          <b>formBuilder.array({valor, validação})</b>, os valores podendo ser
          mais de um checkbox vão ser retornados no nosso <b>FormControl</b> que
          está recebendo o array, podemos trabalhar neles usando o
          <b>
            *ngFor=" let item of formulario.get('frameworks')['controls']; let i
            = index "</b
          >, e tambem <b>{{ frameworks[i] }}</b> fazemos a interpolação passando
          o idex.
        </p>
        <p>
          Podemos tambem retornar apenas os valores checkados do checkbox com
        </p>
        <p>
          <b
            >Formulários: Data Driven: FormArray: Checkboxes Dinâmicos - Aula
            107~108
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Validação customizada</h1>
        <p>
          Para formulários reativos podemos criar as nossas próprias validaçãos
          , como o caso de um CEP invalido, criamos um metodo estatico em outra
          classe, e nele fazemos uma lógica de validação
          <b>return validaCep.test(cep) ? null : { cepInvalido: true };</b>,
          caso o o <b>value</b> do control esteja passe no teste, retornamos
          null, caso contrario retornamos um objeto com o nome da validação e o
          boolean de true, pois o objeto foi reprovado.
        </p>
        <p>
          <b
            >Formulários: Data Driven: Validação Customizada (CEP) - Aula 109
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Validação entre dois campos</h1>
        <p>
          Podemos criar uma validação customizada que verifica se os valores
          entre dois campos são iguais, muito útil para confirmação de e-mail e
          confirmação de senha
        </p>
        <p>
          Podemos escrever na mão, mas tambem temos bibliotecas como a
          <b>ng2-validation</b> que já tem váris tipos de validações prontas
        </p>
        <p>
          <b
            >Formulários: Data Driven: Validação entre dois campos (confirmar
            email) - Aula 110
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Validações assíncronas</h1>
        <p>
          Validações assíncronas, são validações que dependemos do servidor para
          retornar o valor, e neste caso devemos aguardar para realizar a
          validação
        </p>
        <p>
          Com o angular podemos criar um service que contate o servidor e
          verifica o dado, filtramos e retornamos se o dado se encontra no
          servidor
        </p>
        <p>
          No component, criamos um metodo que recebe o FormControl e faz a
          chamado do service passando o seu valor para verificação, usamos o
          <b>.pipe</b> e o <b>.map</b> para realizar uma operador ternário
          <b
            >(todos os operadores rxjs devem ser importados e utilizados dentro
            do .pipe()</b
          >
        </p>
        <p>
          <b
            >.pipe( map((emailExiste) => (emailExiste ? { emailInvalido: true }
            : null)) )</b
          >
        </p>
        <p>
          Nestá validação e se o email for existente, retornamos a validação com
          nome e valor, dentro do <b>FormControl</b>, o terceiro parâmetro são
          validações assincronas e nela passamos nosso método com
          <b>.bind(this)</b>, fazendo a bind com o nosso component, e no
          template do component, realizamos as verificações com o próprio ngIf
          <b>*ngIf="formulario.get('email').status === 'PENDING'"</b> o próprio
          formControl possui o metodo <b>.status</b> que retorna o status que
          retorn o status da validação do control sendo
          <b>VALID, INVALID, PENDING, DISABLED</b>, o pending informa se ainda
          está sendo válidado
        </p>
        <p>
          Importante ressaltar que deve ser colocado o operador
          <b>delay(milisegundos)</b> no inicio do servico para que o mesmo não
          faça requisições a cada novo valor digitado e sim a cada tempo para
          melhorar a performance
        </p>
        <p>
          <b>Formulários: Data Driven:Validação Assíncrona - Aula 111 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Serviços de Mensagens de Erros</h1>
        <p>
          Podemos criar um serviço de mensagem que retorna o erro e o campo,
          para isso, criamos o servico que recebe o nome do campo, o validador
          do campo e o valor da validação como opcional, retornando a mensagem
          de erro de acordo com o tipo de erro, dentro do component que irá
          apresentar as mensagens recebemos com input property o control do form
          e o nome da label, criamos um metodo para a validação que retorna o
          nosso serviço, dentro do metodo iteramos sobre os erros do control e
          caso o campo tenha erro e foi tocado, ira reotrnar o serviço com as
          informações do campo
        </p>
        <p>Tornando assim a nossa iteração de erros muito mais dinamica</p>
        <p>
          <b
            >Formulários: Data Driven: Serviço de Mensagens de Erros - Aula 112
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Reagindo a mudanças reatiamente</h1>
        <p>
          Podemos com formulários reativos reagira mudanças de forma dinamica,
          nos conroles, temos opções como <b>valueChanges</b> e
          <b>statusChange</b>, que nos alerta se o valor ou estado do campo do
          formulário mudar, e de acordo com a mudança utilizar operadores do
          <b>rxjs</b> como observables para itergair e criar a lógica do nosso
          código.
        </p>
        <p>
          <b
            >Formulários: Data Driven: Reagindo à mudanças reativamente - Aula
            113
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Campo Input customizado</h1>
        <p>
          Podemos criar qualquer tipo de campo input com inputs customizados,
          para isso implementamos a interface <b>ControlValueAccessor</b> no
          novo component, e os métodos
        </p>
        <p><b>writeValue</b> atribui valor ao input</p>
        <p><b>registerOnChange</b> executa quando mudar o campor</p>
        <p><b>registerOnTouched</b> executa quando o campo</p>
        <p><b>setDisabledState?</b>setar se for read onlu</p>
        <p>
          Adicionamos os metedos <b>get</b> e o <b>set</b> sobre o <b>value</b>
        </p>
        <p>
          E para que funcione como input, adicionamos no component o
          <b>providers</b> passando um objeto que criamos com o
          <b
            >const INPUT_FIELD_VALUE_ACCESSOR: any = { provide:
            NG_VALUE_ACCESSOR, useExisting: forwardRef(() =>
            InputFieldComponent), multi: true };</b
          >
        </p>
        <p>
          <b>Formulários: Data Driven: Campo input personalizado - Aula 114 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Herança no angular</h1>
        <p>
          Com o typescript do angular podemos criar classes abstratas, que tem
          metodos, e metodos abstratos, e tambem metodos comuns, e ao ser
          extendida, a classe que exetende tem acesso a todos os metodos da
          classe pai.
        </p>
        <p>
          <b>Formulários: Data Driven: Classe base para Forms - Aula 115 </b>
        </p>
      </section>
      <hr />
    </section>
    <hr />
    <hr />
    <section>
      <h1>HTTP / HTTP Client</h1>
      <p>
        As <b>requisições ajax</b>, é como como podemos consumir uma API rest,
        com os verbos HTTP
      </p>
      <p><b>GET</b> retorna os dados da url</p>
      <p><b>POST</b> adiciona dados através da url</p>
      <p><b>PUT</b> modifica os dados de um item</p>
      <p><b>DELET</b> apaga os dados através da URL</p>
      <p>
        <b>HTTP: Http / HttpClient: Introduçãos - Aula 117 </b>
      </p>
      <hr />
      <section>
        <h1>Simulando servdor REST</h1>
        <p>
          Com o <b>json-server</b>, uma biblioteca que simula um servidor REST,
          podemos trabalhar com o front end enquanto não temos um back end
        </p>
        <p>
          Basta instalar <b>npm sudo install -g json-server</b> crirar um
          aqruivo <b>db.json</b> em qualuer lugar do projeto e iniciar com
          <b>json-server --watch db.json</b>, ele rodará e simulará um servidor
          REST
        </p>
        <p>
          <b>HTTP: Simulando servidor REST (json-server) - Aula 119 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Http GET</h1>
        <p>
          Para listar items, devemos fazer a requisição ajax via o HttpClient,
          injetado dentro de um serviço, lá criamos o motodo de
          <b>list()</b> que irá listar capturar o nosso objeto, fazemos o
          <b>this.http.get(linkApi)</b>, e tambem podemos criar uma interface
          para tipar o tipo de item que vamos receber, adicionamos a interface
          logo após o get <b>.get< Interface ></b>
        </p>
        <p>
          Após criar o metodo no serviço, dentro do component que irá consumir,
          criamos um atributo que irá receber os dados e injetamos o serviço, e
          dentro do <b>NgOnInit</b> utilizamos o metodo criado dentro do serviço
          e aplicamos o <b>.subscribe()</b> para que possamos capturaro item.
        </p>
        <p>
          <b>HTTP: GET listar registros - Aula 120 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Pipe Async</h1>
        <p>
          Podemos tambem ao invés de realizar o subscribe, criar um atributo com
          o tipo do retorno da resqusição <b>Observable < Interface ></b>, e
          criamos a váriavel com o <b>$</b> no final para identifarmos que se
          trata de um observable, e dentro do <b>ngOnInit</b> este atributo irá
          receber o servico com o metodo de requisição, sem precisar do
          <b>subscribe</b>
        </p>
        <p>
          Dentro do component podemos criar um <b>*ngIf</b> para somente exibir
          os dados quando a váriavel estiver disponivel, e para isso dentro do
          if podemos adicionar o <b> | async</b> que realiza o subscribe de
          forma automatica.
        </p>
        <p>
          Podemos criar um <b>ng-template</b> para exbir algum dado enquanto
          carrega os dados, criamos o ng-template com alguma variável local com
          <b>#loading</b>, e no <b>*ngIf</b>, adicionamos o
          <b>else</b> informando a váriavel de template criada.
        </p>
        <p>
          Recomendado utilizar o <b> | async</b> sempre que possível pois fica a
          cargo do proprio angular o subscribe e o unsusbcribe
        </p>
        <p>Exemplo: <b> *ngIf="cursos$ | async as cursos; else loading"</b></p>
        <p>
          <b>HTTP: GET + Pipe Async - Aula 122 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Unsubscribe Automático</h1>
        <p>
          Sempre que tivermos um subscribe em um component, devemos sempre fazer
          o <b>unsubscribe</b>, pois se não realizarmos podemos ter problemas
          com <b>vazamento de memória</b>, pois mesmo que o component seja
          destruido, ele escuta o subscribe, para realizar o procedimento ,
          temos o pipe async <b>| async</b>, que realiza o unsubscribe
          automatico.
        </p>
        <p>
          <b>takeUntil(Observable) </b>que vai manter o subscribe até um
          observable passado como parâmetro ser emitido, para isso criamos um
          observable e no life clicle, do <b>ngOnDestroy</b> emitimos um evento
        </p>
        <p>
          <b>take(1)</b> realiza a requisição apenas o numero de vezes
          informado, após isso, é encerrado.
        </p>
        <p>
          E tambem o subscribe manual, onde criamos um atributo que é um
          <b>Subscription</b> e atribuimos a ele a nossa requisição e dentro do
          <b>ngOnDestroy</b> escrevemos que devemos dar o unsubscribe,
          <b>minhaSub.unsubscribe()</b>
        </p>
        <p>
          <b>HTTP: Unsubscribe automatico - Aula 123 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Capturando erros</h1>
        <p>
          Para capturar erros no angular, podemos com o <b>rxjs</b> dentro do
          método <b>.pipe()</b> logo após tuilizar o metodo de requisição, e
          dentro do pipe utilizar o método
          <b>catchError(error => { fazer algo com o error} </b>, assim
          capturamos o mesmo, e este metodo pode retornar um objservable
        </p>
        <p>
          Podemos tambem capturar o erro direto no subscribe, no segundo
          parametro e informar a lógica.
        </p>
        <p>
          Para que seja possível mostrar o erro na tela, criamos um atributo
          <b>error$</b> que é um observable com <b>new Subject< tipo >() </b>,
          passamos o tipo, e dentro do <b>catchError()</b> damos um
          <b>.next(true)</b> para emitir um valor que deu erro, e no template
          usamos o <b>*ngIf</b> com o pipe async da váriavel de error
        </p>
        <p>
          <b>HTTP: Capturando Erros (+Erro com async) - Aula 124 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Alerta de Erro</h1>
        <p>
          Para criarmos alertas de erros, realizamos o procedimento de acordo
          com o framework CSS que estamos utilizando, mas independente de qual
          seja, devemos realizar os imports do module e do service
        </p>
        <p>No geral criamos component para servir como modal.</p>
        <p>
          E tambem podemos criar um serviço genérico para os alerts, fazendo om
          que escolhamos a mensagem e o tipo de alera.
        </p>
        <p>
          <b
            >HTTP: Alerta de Erro && Serviço de alerta genérico - Aula 125~126
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>POST</h1>
        <p>
          Através do metodo <b>POST</b>, conseguimos adicionar valores a nossa
          api, para isso, com o nosso metodo HTTP conseguimos dar um
          <b>.post(url.da.api)</b> passando a url da api, criando um método
          assim, basta chama-lo no component que vai consumir, muito usado em
          metodos de submit, mas para que ocorra o processo, não podemos
          esquecer o
          <b
            >subscribe(sucesso => lógica para sucesso, error => lógica para
            error)</b
          >,
        </p>
        <p>
          <b>HTTP: POST Criando Cursos - 128 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Criando edição</h1>
        <p>
          Para criar o <b>Update</b> do <b>CRUD</b>, criar um metodo no servioce
          que de o <b>get</b> no item selecionado, e dentro do component podemos
          criar um metodo para pegar os params da rota ativa
          <b>this.route.params .pipe</b> e através do pipe, adicionar os
          operadores para aninhar observables, o mais usado é o
          <b>switchMap()</b>, que retorna outro observable e nele criamos edição
          do formulario.
        </p>
        <p><b>switchMap</b>substitui a ultima requisição</p>
        <p><b>concatMap</b> ordem da requisição importa, será feito em ordem</p>
        <p>
          <b>mergeMap</b> ordem não importa, realiza as requsições em ordem
          aleatoria
        </p>
        <p>
          <b>exhaustMap</b> utilizada em casos de logim, realiza e espera a
          resposta das requisições
        </p>
        <p>
          <b>HTTP: Editando Cursos e Observables aninhados - Aula 129 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Utilizando resolver</h1>
        <p>
          Podemos criar resolves para carregar o dado antes de ser renderizado,
          através dos guards <b>resolve</b>
        </p>
        <p>
          <b>HTTP: Editando Cursos + Resolver (Rota) - Aula 130 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>PUT</h1>
        <p>
          Para realizar o put, no submit devemos verificar se o item que está
          sendo enviado ja existe, e caso exista, invocamos o service com o
          metodo de <b>put</b>, passando o link do item a ser atualizado e o
          objeto que contem as informações
        </p>
        <p>
          Podemos tambem criar o metodo para verificar se é criação ou
          atualização dentro do proprio serviço com if e else invocando os
          metodos correspondentes, e no component apenas se dar
          <b>subscribe</b> no metodo de verificação e passando as mensagens de
          erro e sucesso de acordo com criação ou atualização, em variáveis com
          if.
        </p>
        <p>
          <b>HTTP: PUT Atualizando Cursos - Aula 131 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Pop up de confirmação</h1>
        <p>
          Para o metodo <b>delete</b> podemos e devemos criar um pop up que
          questiona a confirmação da exclusão daquele dado, para isso no
          component, dependendo do nosso framework css, criamos uma referencia
          do modal, e invocamos o servico para criação do modal, passando a
          mensagem que está no template, com uma váriavel de template, e para
          acessa-lo dentro do component usamos o decorator
          <b>@ViewChild(noma-da-variavel) nome-da-variavel</b>
        </p>
        <p>
          Após a criação do modal, criamos as lógicas dos botoes de aceite e
          delete que serão outros dois métodos com respectivas lógicas, para
          excluir o arquivo, mandamos a requisisção de
          <b>http.delete(caminho/url)</b>, e será excluido do nosso servidor
        </p>
        <p>
          Podemos tambem criar um component que é responsável por um popup
          genérico, que será personalizavel ccom a invocação, para isso usamos
          <b>@Input</b> property, e para retornar caso o botão de sim seja
          clicado, podemos criar uma variável do tipo <b>Subject< tipo></b>, e
          no <b>ngOnInit()</b> atribuimos um <b>new Subject()</b> para a
          variável, e criamos um método que e escutamos o evento de click, ao
          ser clicado, a variável com <b>Subject</b> emite um valor,
          <b>variavel.next(valor)</b>
        </p>
        <p>
          No component que estará consumindo o modal genérico podemos ouvir,
          criamos uma variável que recebe o método de invocação do modal, e em
          seguida utilizar o <b>vairval.asObservable()</b> que teremos acesso a
          todos os métodos de um observable
        </p>
        <p>
          <b>HTTP: Popup de Confirmação para remover Cursos - Aula 132~133 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Serviço genérico de CRUD</h1>
        <p>
          Caso nossa aplicação precise de mais de um serviço de <b>CRUD</b>,
          podemos criar um serviço genérico usando a tipagem generica
          <b>CrudService< T > </b>, e ao invocar o servico passando a classe que
          queremos iterar, e dentro do serviço genérico terá todas as
          funcionalidades básicas do <b>CRUD</b>, caso desejamos alterar,
          podemos extender a classe e sobrescrever os métodos
        </p>
        <p>
          <b>HTTP: Serviço Genérico de CRUD - Aula 134 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Formulário de Upload</h1>
        <p>
          Para criar um formulário para upload de arquivos podemos com o nosso
          framework mesmo realizar o procedimento.
        </p>
        <p>
          Para chegar no valor do elemento, podemos escutar o evento
          <b>onChange</b> no input de files, e recebemos se for mais de um
          arquivo um array de files em <b>event.srcElement.files</b>
        </p>
        <p>Dica: Sempre evitar uso de bibliotecas desnecessárias.</p>
        <p>
          <b
            >HTTP: Upload de Arquivo: Formulário Upload com Bootstrap 4 - Aula
            135
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Back end do upload</h1>
        <p>
          Quando vamos fazer upload de arquivos, nosso código back end, vai
          dependenr da linguagem, e com o node em desenvolvimento, devemos
          utilizar a biblioteca <b>Cors</b>, que nos permite evitar erro com o
          uso de javascript com cors, rodando os servidores do front e back end
          ao mesmo tempo e realizando requisições
        </p>
        <p>
          Temos tambem que utilizar middlewares como <b>multipart</b> ou
          <b>formidable</b>
        </p>
        <p>
          <b
            >HTTP: Http: Upload de Arquivo: Back-end com Node.js" - Aula 136
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Request com FormData</h1>
        <p>
          Para capturar os arquivos e enviar para o servidor back end, podemos
          declarar uma variável do tipo
          <b
            >Set< File >, que não permite items duplicados ao contrário do
            array, e para adicionar um arquvio basta usar o método
            <b>this.files.add(valor)</b></b
          >
        </p>
        <p>
          Para realizar o upload, criamos um service com o metodo, que vai
          receber como parâmetro os arquivos como <b>Set< File > </b> e como
          segundo parâmetro a url como string, ficando
          <b>upload(files: Set< File >, url: string) </b>
        </p>
        <p>
          Além dos metodos que consta no <b>HttpClient</b> como
          <b>GET, POST, PUT, e DELETE </b>, podemos com o Angular criar request
          personalizado, para isso atribuimos a uma variável a classe
          <b>new HttpRequest()</b>, passando como parâmetro o método, a url e
          body ou cabeçalho do request
          <b>new HttpRequest('POST', url, formData)</b>, sendo o
          <b>formData</b>, uma variável que instancia o <b>new FormData()</b>,
          responsável pelo corpo da request, para adicionar os arquivos no
          formData, usamos o metodo append passando o nome do campo, o blob do
          arquivo, e em caso de arquivos o nome.
          <b>formData.append('file', file, file.name')</b>
        </p>
        <p>
          <b>HTTP: Http Upload de Arquivo: Request com FormData - Aula 137 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Angular Proxy</h1>
        <p>
          Quando desenvolvento o back e o front end no mesmo ambiente, para
          evitar o uso do <b>cors</b> podemos utilizar o angular proxy, criamos
          na pasta raiz do projeto o <b>proxy.conf.js</b>, nele criamos uma
          const, que ao ser navegado a tal url, o proprio proxy se encarrega de
          navegar até a url informada
        </p>
        <code
          >const PROXY_CONFIG = [ { context: ["/api"], target:
          "http://localhost:8000", secure: false, logLevel: "debug",
          pathRewrite: { "^/api": "" }, }, ]; module.exports = PROXY_CONFIG;
        </code>
        <p>
          Onde passamos um array com um objeto tendo o <b>context</b> que
          representa quando o proxy será acionado, o <b>target</b>, qual a url
          será o alvo, <b>secure</b> tru ou false, true para <b>https</b>,
          <b>logLevel</b> para informações de debug, e <b>pathRewrite</b> mais
          usada quando trabalhamos com api com rotas já criadas sem o nosso
          <b>/api</b>, então sobrescrevemos a url e retiramos o código
          <b>api</b> via regex
        </p>
        <p>
          <b>HTTP: Removendo CORS com Angular Proxy - Aula 138 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Observando eventos Http</h1>
        <p>
          Para criar uma barra de progressso por exemplo, temos como observar
          eventos do Http, dentro do serviço que realiza a requisição, no
          <b>POST</b>, como terceiro parametro podemos passar um objeto com
          configurações para obervar eventos.
        </p>
        <p>
          <code><b>{ observe: 'events', reportProgress: true, })</b></code>
        </p>
        <p>
          Podendo ser adicionado outros eventos para rastreio, e dentro do
          component como response do subscribe, obtemos o http event, que
          tipamos como <b>HttpEvent</b> então conseguimos todas as iterações
          sobre o evento http e o seu tipo.
        </p>
        <p>
          <b
            >HTTP: Upload Arquivo: Barra de Progresso + Observando Eventos Http
            - Aula 139
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Operador RxJS Customizado</h1>
        <p>
          Consguimos criar operadores RxJs customizados, criando um novo
          arquivos, por convenção na pasta de <b>shared</b>, e dentro do arquivo
          criamos funções que podem ser exportadas com o tipo generico
          <b>export function exemplo< T > () {return pipe (lógica)} </b>,
          utilizando o pipe e os próprios operadores do rxJs para criar o nosso
          operador customizado.
        </p>
        <p>
          <b>HTTP: Criando operador RxJS customizado - Aula 140 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Download de arquivos Angular</h1>
        <p>
          Para realizar downloads de arquivos, recebemos da nossa api o response
          com o respectivo arquivo, e no nosso serviço, dentro do subscribe
          criamos um uma variável com blob recebendo a url com
        </p>
        <code> <b>const blob = window.URL.createObjectURL(file)</b> </code>
        <p>
          E tambem devemos criar uma elemento <b>a</b>, adicionar o href o blob
          com o link, criado e forçar um click com <b>link.click()</b>, depois
          removemos o link do blobl <b>window.URL.revokeObjectURL(blob)</b>, e
          removemos o link <b>link.remove</b>.
        </p>
        <p>
          <b>HTTP:Download de Arquivo - Aula 141 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>HttpParams</h1>
        <p>
          Para fazer pesquisas em URLs de APIs, temos e devemos que usar
          parâmetros de forma dinâmica com o nosso usuário, e na requisição,
          passamos os parametros com
        </p>
        <code><b>const params = {search: value, fields: fields}</b></code>
        <p>
          Um objeto com o nome <b>params</b>, e o campo e o valor referente ao
          parâmetro,ou tambem usando instânciando a classe <b>HttpParams()</b> e
          setando os campos e valores
        </p>
        <code
          ><b
            >let params = new HttpParams(); params = params.set('search',
            value); params = params.set('fields', fields')</b
          ></code
        >
        <p>
          E passamos para a requisição como parâmetro a variável que carrega os
          params, <b>this.http.get(url, {params})</b>
        </p>
        <p>
          <b>HTTP: Passando Parâmetros na URL (HttpParams) - Aula 143 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Pesquisa reativa</h1>
        <p>
          Para fazer uma pesquisa reativa com o angular, aquele tipo de pesquisa
          que é realizada enquanto digitamos o valor, usamos diversos operadores
          do rxjs, começamos com o observable de mudança do valor do form
          <b>campo.valueChanges.pipe()</b> dentro do pipe, vamos usar o
          <b>map</b> para realizar o <b>.trim()</b> removendo qualquer espaço em
          branco do valor da busca <b>map((value) => value.trim()),</b>, em
          seguida, fazemos o filtro do valor para que seja realizado a
          requisição apenas com uma certa quantidade de caracteres
          <b>filter((value) => value.length > 1),</b>, usamos tambem o
          <b>debounceTime(300),</b> para realizar a requisição apenas após algum
          tempo de digitação, evitando requisição a cada letra e espera apenas
          após algumas palavras formadas, e tambem para evitar que seja
          realizado requisições com o mesmo valor usamos o
          <b>distinctUntilChanged(),</b> e por ultimo utilizamos o
          <b>switchMap()</b> para usar observables aninhados e realizar a
          requisição.
        </p>
        <p>
          <b>HTTP: Pesquisa/Busca com Programação Reativa - Aula 144 </b>
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Debbug</h1>

      <section>
        <h1>Augury</h1>
        <p>
          Podemos realizar o debugg com o <b>Angury</b> uma extenção do chrome,
          que nos mostra todos os componentes, as arvores de dependencia, os
          dados do component, e tambem podemos utilizar os break points
        </p>
        <p>
          <b>Debbug: Debug com Augury - Aula 145 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>VS Code</h1>
        <p>
          Conseguimos tambem realizar o debug da aplicação através do
          <b>VS Code</b>, para isso instalamos a extenção do chorme dentro do
          visual studio code, e adicionamos a configuração dentro do debbuger,
          podemaos tambem utilizar os breakpoints e tambem breakpoints in line
          para verificar os dados da aplicação
        </p>
        <p>
          <b>Debbug:Debug com Visual Studio Code - Aula 146 </b>
        </p>
      </section>
    </section>
    <hr />
    <hr />
    <section>
      <h1>Deploy com angular</h1>
      <section>
        <h1>ng build --prod</h1>
        <p>
          Para realizar o build de produção, basta rodar o <b>npm run build</b>,
          pois será gerado o build de produção, caso usamos as variaveis de
          ambiente,<b> enviroments</b> temos que adicionar a flagg
          <b>--prod</b> dentro do package.json no script de build, após isto os
          arquivos staticos serão gerados na pasta <b>dist/meu-app</b> e caso
          desejamos configurar os browser suportados, acessamos o arquivo
          <b>browserslistrc</b>
        </p>
        <p>
          <b
            >Deploy: Build de Produção + Suporte ao Internet Explorer - Aula 147
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Deploy com firese</h1>
        <p>
          Para realizar o deploy com firebase, criamos o projeto dentro do
          firebase, e instalamos o <b>npm install -g firebase-tools</b> de forma
          global fazemos login com a nossa conta do g-mail, com
          <b>firebase login</b>, aplicamos o <b>firebase init</b> e iniciamos o
          firebase no nosso projeto, selecionamos para realizar o hosting, e
          selecionamos o nosso projeto e a pasta de dist para subir e realizamos
          o deploy com <b>firebase deploy</b>
        </p>
        <p>
          <b>Deploy: Deploy em Produção (Firebase Hosting) - Aula 148 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Deploy em produção com ng deploy</h1>
        <p>
          Podemos realizar o build e o deploy com o <b>ng deploy</b>, para
          podermos realizar isso, devemos adicionar com
          <b>ng add @deploy-server</b> e após basta dar o <b>ng deploy</b> que
          será feito o build e o deploy de forma simples.
        </p>
        <p>Lista de servers</p>
        <p><b>@angular/fire</b></p>
        <p><b>@azure/ng-deploy</b></p>
        <p><b>@zeit/ng-deploy</b></p>
        <p><b>@netlify-builder/deploy</b></p>
        <p><b>angular-cli-ghpages</b></p>
        <p><b>ngx-deploy-npm</b></p>
        <p><b>@jefiozie/ngx-aws-deploy</b></p>
        <p>
          <b>Deploy: Deploy em Produção com ng deploy (Firebase) - Aula 149 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Gerando uma imagem Docker</h1>
        <p>
          Conseguimos gerar um container contendo a imagem do nosso projeto com
          o Docker, junto com o docker realizamos o procedimento de instalação
          do NPM e o build do projeto , e tambem usamos o <b>nginx</b>, para
          upar o projeto em um servidor http, e criamos a imagem e mandamos para
          o dockerhub
        </p>
        <p>
          <b>Deploy: Gerando imagem Docker com Build de Produção - Aula 150 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Deploy google cloud (Cloud Run) com Docker</h1>
        <p>
          Temos o servidor <b>Cloud Run</b> da google que conseguimos containers
          e realizar deploys de forma simples
        </p>
        <p>
          <b
            >Deploy: Imagem Docker: Deploy Google Cloud (Cloud Run) - Aula 151
          </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Deploy Oracle Cloud</h1>
        <p></p>
        <p>
          <b>Deploy: Imagem Docker: Deploy Oracle Cloud - Aula 152 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Deploy Microsoft Azure</h1>
        <p>
          Assim como a nuvem da google, a microsoft tem o <b>Azure</b> que é um
          servidor nuvem que permite upar imagens de container.
        </p>
        <p>
          <b>Deploy: Imagem Docker: Deploy Microsoft Azure - Aula 153 </b>
        </p>
      </section>
      <hr />
      <section>
        <h1>Deploy Amazon</h1>
        <p></p>
        <p>
          <b>Deploy: Imagem Docker: Deploy Amazon AWS - Aula 154 </b>
        </p>
      </section>
      <hr />
    </section>
  </body>
</html>
